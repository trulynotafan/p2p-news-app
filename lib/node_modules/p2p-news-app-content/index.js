// Blog content operations - posts, profiles, subscriptions, reading
// Handles all user-facing content actions for the blog app
const b4a = require('b4a')

module.exports = blog_content

function blog_content (get_state, helpers) {
  const { audit_log, setup_peer_autobase, identity } = helpers

  const api = {
    // Posts
    create_post,
    get_posts,
    get_my_posts,
    get_peer_blogs,
    // Profile
    create_default_profile,
    get_profile,
    get_avatar_content,
    upload_avatar,
    // Subscriptions
    subscribe,
    unsubscribe,
    // Blog info
    get_blog_username,
    get_blog_drive_key,
    get_blog_profile_drive_key,
    get_blog_events_drive_key,
    // Subscription data access
    get_subscribed_peers,
    add_subscribed_peer,
    remove_subscribed_peer
  }
  return api

  /***************************************
  POST MANAGEMENT
  ***************************************/

  async function create_post (title, content) {
    const state = get_state()
    const drive = state.ds_manager.get('drive')
    const metadata = state.ds_manager.get('metadata')
    const created = Date.now()
    const filepath = `/posts/${created}.json`
    const post_data = { title, content, created }
    await drive.put(filepath, Buffer.from(JSON.stringify(post_data)))
    await metadata.append({
      type: 'blog-post',
      data: { filepath, created }
    })
    await audit_log('create_post', { title, filepath })
  }

  async function get_posts (key = null) {
    const state = get_state()
    const target_key = key || state.ds_manager.get_key('metadata')
    const is_my_blog = !key || key === state.ds_manager.get_key('metadata')
    const metadata = is_my_blog ? state.ds_manager.get('metadata') : state.autobase_cache.get(target_key)
    const drive = is_my_blog ? state.ds_manager.get('drive') : state.drive_cache.get(target_key)
    if (!metadata || !drive || !metadata.view || !metadata.view.length) return []
    const posts = []
    for (let i = 0; i < metadata.view.length; i++) {
      try {
        const raw = await metadata.view.get(i)
        const entry = JSON.parse(raw)
        if (validate_blog_post(entry)) {
          const post_buffer = await drive.get(entry.data.filepath)
          if (post_buffer) {
            const post = JSON.parse(post_buffer.toString())
            posts.push(post)
          }
        }
      } catch (err) {
        console.error('Error reading post:', err)
      }
    }
    return posts.sort((a, b) => b.created - a.created)
  }

  function get_my_posts () { return get_posts() }

  async function get_peer_blogs () {
    const state = get_state()
    const blogs = new Map()
    const subscribed = await get_subscribed_peers()
    for (const key of subscribed) {
      const blog_data = state.discovered_blogs.get(key)
      if (blog_data) {
        const posts = await get_posts(key)
        blogs.set(key, { ...blog_data, posts })
      }
    }
    return blogs
  }

  /***************************************
  PROFILE MANAGEMENT
  ***************************************/

  async function create_default_profile (username) {
    const state = get_state()
    const profile_drive = state.ds_manager.get('profile')
    if (!profile_drive) return
    if (await profile_drive.get('/profile.json')) return
    const default_avatar = '<svg><text x="50%" y="50%" font-size="120" text-anchor="middle" dominant-baseline="middle">ðŸ‘¤</text></svg>'
    await profile_drive.put('/avatar.svg', b4a.from(default_avatar))
    await profile_drive.put('/profile.json', b4a.from(JSON.stringify({
      name: username,
      avatar: '/avatar.svg'
    })))
  }

  async function get_profile (profile_key = null) {
    if (typeof profile_key === 'string') return null
    const state = get_state()
    const profile_drive = state.ds_manager.get('profile')
    if (!profile_drive) return null
    try {
      await profile_drive.ready()
      const profile_data = await profile_drive.get('/profile.json')
      if (!profile_data) return null
      return JSON.parse(b4a.toString(profile_data))
    } catch (err) {
      console.error('Error getting profile:', err)
      return null
    }
  }

  async function get_avatar_content (profile_key = null) {
    const state = get_state()
    const profile_drive = state.ds_manager.get('profile')
    if (!profile_drive) return null
    try {
      await profile_drive.ready()
      const profile = await get_profile(profile_key)
      if (!profile || !profile.avatar) return null
      const avatar_data = await profile_drive.get(profile.avatar)
      if (!avatar_data) return null
      if (profile.avatar.endsWith('.svg')) return b4a.toString(avatar_data)
      const ext = profile.avatar.split('.').pop().toLowerCase()
      const mime_type = ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : `image/${ext}`
      const base64 = b4a.toString(avatar_data, 'base64')
      return `data:${mime_type};base64,${base64}`
    } catch (err) {
      return null
    }
  }

  async function upload_avatar (imageData, filename) {
    const state = get_state()
    const profile_drive = state.ds_manager.get('profile')
    if (!profile_drive) throw new Error('Profile drive not initialized')
    const ext = filename.split('.').pop().toLowerCase()
    const avatar_path = `/avatar.${ext}`
    await profile_drive.put(avatar_path, b4a.from(imageData))
    const profile = await get_profile()
    const updated_profile = { ...profile, avatar: avatar_path }
    await profile_drive.put('/profile.json', b4a.from(JSON.stringify(updated_profile)))
    await audit_log('upload_avatar', { avatar_path })
    state.emitter.emit('update')
  }

  /***************************************
  SUBSCRIPTION MANAGEMENT
  ***************************************/

  async function subscribe (key) {
    const state = get_state()
    if (!key || typeof key !== 'string') return false
    const my_key = state.ds_manager.get_key('metadata')
    if (key === my_key) return false
    try {
      const key_buffer = b4a.from(key, 'hex')
      await setup_peer_autobase(key, key_buffer)
      await add_subscribed_peer(key)
      await audit_log('subscribe', { peer_key: key })
      state.emitter.emit('update')
      return true
    } catch (err) {
      console.error('Subscribe error:', err)
      return false
    }
  }

  async function unsubscribe (key) {
    const state = get_state()
    await remove_subscribed_peer(key)
    const peer_autobase = state.autobase_cache.get(key)
    if (peer_autobase) {
      await peer_autobase.close()
      state.autobase_cache.delete(key)
    }
    const peer_drive = state.drive_cache.get(key)
    if (peer_drive) {
      await peer_drive.close()
      state.drive_cache.delete(key)
    }
    await audit_log('unsubscribe', { peer_key: key })
    state.emitter.emit('update')
  }

  /***************************************
  BLOG INFO
  ***************************************/

  async function get_blog_username () {
    const state = get_state()
    if (!state.ds_manager) return null
    const metadata = state.ds_manager.get('metadata')
    if (!metadata || !metadata.view || metadata.view.length === 0) return null
    try {
      const init_raw = await metadata.view.get(0)
      const init_entry = JSON.parse(init_raw)
      return validate_blog_init(init_entry) ? init_entry.data.username : null
    } catch {
      return null
    }
  }

  async function get_blog_drive_key (key_name) {
    const state = get_state()
    const metadata = state.ds_manager.get('metadata')
    if (!metadata || metadata.view.length < 2) return null
    try {
      const extended_raw = await metadata.view.get(1)
      const extended_entry = JSON.parse(extended_raw)
      return extended_entry.data?.[key_name] || null
    } catch {
      return null
    }
  }

  function get_blog_profile_drive_key () { return get_blog_drive_key('profile_drive_key') }
  function get_blog_events_drive_key () { return get_blog_drive_key('events_drive_key') }

  /***************************************
  SUBSCRIPTION HELPERS (using vault API)
  ***************************************/

  async function get_subscribed_peers () {
    const peers = await identity.vault_get('subscribed_peers')
    return peers || []
  }

  async function add_subscribed_peer (key) {
    const peers = await get_subscribed_peers()
    if (!peers.includes(key)) {
      peers.push(key)
      await identity.vault_put('subscribed_peers', peers)
    }
  }

  async function remove_subscribed_peer (key) {
    const peers = await get_subscribed_peers()
    await identity.vault_put('subscribed_peers', peers.filter(k => k !== key))
  }
}

/***************************************
GENERAL HELPER FUNCTIONS
***************************************/

function validate_blog_init (entry) {
  const { type, data = {} } = entry || {}
  return type === 'blog-init' &&
    typeof data.username === 'string' &&
    typeof data.title === 'string' &&
    typeof data.drive_key === 'string'
}

function validate_blog_post (entry) {
  const { type, data = {} } = entry || {}
  return type === 'blog-post' &&
    typeof data.filepath === 'string' &&
    typeof data.created === 'number'
}
