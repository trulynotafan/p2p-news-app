const Autobase = require('autobase')
const Hyperbee = require('hyperbee')
const { EventEmitter } = require('events')
const b4a = require('b4a')

function create_autobee(options) {
  const { store, bootstrap, opts = {} } = options
  const emitter = new EventEmitter()
  const state = { store, bee: null, bootstrap, opts, base: null }

  function handle_autobase_open(store) {
    const bee_store = store.base.store.namespace('autobee')
    const core = bee_store.get({ name: 'view' })
    const bee = new Hyperbee(core, {
      keyEncoding: opts.keyEncoding || 'utf-8',
      valueEncoding: opts.valueEncoding || 'json',
      extension: false
    })
    return { bee }
  }

  async function handle_autobase_apply(nodes, view, base) {
    const batch = view.bee.batch()
    for (const node of nodes) {
      if (node.value === null) continue
      const { type, data } = node.value
      if (type === 'put') {
        await batch.put(data.key, data.value)
      } else if (type === 'del') {
        await batch.del(data.key)
      } else if (type === 'add_writer') {
        await base.addWriter(b4a.from(data.key, 'hex'), { indexer: data.is_indexer })
      }
    }
    await batch.flush()
  }

  state.base = new Autobase(store, bootstrap, {
    valueEncoding: 'json',
    open: handle_autobase_open,
    apply: handle_autobase_apply,
    ackInterval: opts.ack_interval || 1000,
    ackThreshold: opts.ack_threshold || 1,
    fastForward: false
  })

  state.base.on('update', () => {
    if (state.base.view && state.base.view.bee) {
      state.bee = state.base.view.bee
    }
    emitter.emit('update')
  })

  const api = {
    on: (event, listener) => emitter.on(event, listener),
    off: (event, listener) => emitter.off(event, listener),
    get base() { return state.base },
    get view() { return state.bee },
    get version() { return state.bee ? state.bee.version : 0 },
    get id() { return state.bee ? state.bee.id : null },
    get key() { return state.base ? state.base.key : null },
    get discovery_key() { return state.bee ? state.bee.discoveryKey : null },
    get writable() { return state.base ? state.base.writable : false },
    get readable() { return state.bee ? state.bee.readable : false },
    get core() { return state.bee ? state.bee.core : null },

    async ready() {
      await state.base.ready()
      await state.base.update()
      if (state.base.view && state.base.view.bee) {
        state.bee = state.base.view.bee
      }
    },

    async close() {
      if (state.bee) await state.bee.close()
      if (state.base) await state.base.close()
    },

    async put(key, value) {
      await state.base.append({ type: 'put', data: { key, value } })
      await state.base.update()
      return state.base.latest
    },

    async del(key) {
      await state.base.append({ type: 'del', data: { key } })
      await state.base.update()
      return state.base.latest
    },

    async get(key, opts) {
      if (!state.bee) await this.ready()
      return state.bee.get(key, opts)
    },

    async get_by_seq(seq, opts) {
      if (!state.bee) await this.ready()
      return state.bee.getBySeq(seq, opts)
    },

    async peek(range, opts) {
      if (!state.bee) await this.ready()
      return state.bee.peek(range, opts)
    },

    create_read_stream(range, opts) {
      return state.bee.createReadStream(range, opts)
    },

    create_history_stream(opts) {
      return state.bee.createHistoryStream(opts)
    },

    create_diff_stream(other_version, range, opts) {
      return state.bee.createDiffStream(other_version, range, opts)
    },

    watch(range, opts) {
      return state.bee.watch(range, opts)
    },

    async get_and_watch(key, opts) {
      if (!state.bee) await this.ready()
      return state.bee.getAndWatch(key, opts)
    },

    checkout(version, opts) {
      return state.bee.checkout(version, opts)
    },

    snapshot(opts) {
      return state.bee.snapshot(opts)
    },

    sub(prefix, opts) {
      return state.bee.sub(prefix, opts)
    },

    batch(opts) {
      return state.bee.batch(opts)
    },

    async add_writer(key, is_indexer = true) {
      const key_str = typeof key === 'string' ? key : key.toString('hex')
      await state.base.append({ type: 'add_writer', data: { key: key_str, is_indexer } })
      await state.base.update()
    },

    async update() {
      return state.base.update()
    },

    replicate(stream_or_initiator, opts = {}) {
      return state.store.replicate(stream_or_initiator, opts)
    }
  }

  return api
}

module.exports = { create_autobee }
