const Autobase = require('autobase')
const Hyperbee = require('hyperbee')
const b4a = require('b4a')

module.exports = { create_autobee }

function create_autobee(options) {
  const { store, bootstrap, opts = {} } = options
  const emitter = make_emitter()
  const state = { store, bee: null, bootstrap, opts, base: null }

  state.base = new Autobase(store, bootstrap, {
    valueEncoding: 'json',
    open: handle_autobase_open,
    apply: handle_autobase_apply,
    ackInterval: opts.ack_interval || 1000,
    ackThreshold: opts.ack_threshold || 1,
    fastForward: false
  })

  state.base.on('update', () => {
    if (state.base.view && state.base.view.bee) {
      state.bee = state.base.view.bee
    }
    emitter.emit('update')
  })

  const api = {
    get base() { return state.base },
    get view() { return state.bee },
    get version() { return state.bee ? state.bee.version : 0 },
    get id() { return state.bee ? state.bee.id : null },
    get key() { return state.base ? state.base.key : null },
    get discovery_key() { return state.bee ? state.bee.discoveryKey : null },
    get writable() { return state.base ? state.base.writable : false },
    get readable() { return state.bee ? state.bee.readable : false },
    get core() { return state.bee ? state.bee.core : null },
    on,
    off,
    ready,
    close,
    put,
    del,
    get,
    get_by_seq,
    peek,
    create_read_stream,
    create_history_stream,
    create_diff_stream,
    watch,
    get_and_watch,
    checkout,
    snapshot,
    sub,
    batch,
    add_writer,
    update,
    replicate
  }

  return api

// ============================================================================
// Internal functions
// ============================================================================

  function handle_autobase_open(store) {
    const bee_store = store.base.store.namespace('autobee')
    const core = bee_store.get({ name: 'view' })
    const bee = new Hyperbee(core, {
      keyEncoding: opts.keyEncoding || 'utf-8',
      valueEncoding: opts.valueEncoding || 'json',
      extension: false
    })
    return { bee }
  }

  async function handle_autobase_apply(nodes, view, base) {
    const batch = view.bee.batch()
    for (const node of nodes) {
      if (node.value === null) continue
      const { type, data } = node.value
      if (type === 'put') {
        await batch.put(data.key, data.value)
      } else if (type === 'del') {
        await batch.del(data.key)
      } else if (type === 'add_writer') {
        await base.addWriter(b4a.from(data.key, 'hex'), { indexer: data.is_indexer })
      }
    }
    await batch.flush()
  }

  function on(event, listener) {
    emitter.on(event, listener)
  }

  function off(event, listener) {
    emitter.off(event, listener)
  }

  async function ready() {
    await state.base.ready()
    await state.base.update()
    if (state.base.view && state.base.view.bee) {
      state.bee = state.base.view.bee
    }
  }

  async function close() {
    if (state.bee) await state.bee.close()
    if (state.base) await state.base.close()
  }

  async function put(key, value) {
    await state.base.append({ type: 'put', data: { key, value } })
    await state.base.update()
    return state.base.latest
  }

  async function del(key) {
    await state.base.append({ type: 'del', data: { key } })
    await state.base.update()
    return state.base.latest
  }

  async function get(key, opts) {
    if (!state.bee) await ready()
    return state.bee.get(key, opts)
  }

  async function get_by_seq(seq, opts) {
    if (!state.bee) await ready()
    return state.bee.getBySeq(seq, opts)
  }

  async function peek(range, opts) {
    if (!state.bee) await ready()
    return state.bee.peek(range, opts)
  }

  function create_read_stream(range, opts) {
    return state.bee.createReadStream(range, opts)
  }

  function create_history_stream(opts) {
    return state.bee.createHistoryStream(opts)
  }

  function create_diff_stream(other_version, range, opts) {
    return state.bee.createDiffStream(other_version, range, opts)
  }

  function watch(range, opts) {
    return state.bee.watch(range, opts)
  }

  async function get_and_watch(key, opts) {
    if (!state.bee) await ready()
    return state.bee.getAndWatch(key, opts)
  }

  function checkout(version, opts) {
    return state.bee.checkout(version, opts)
  }

  function snapshot(opts) {
    return state.bee.snapshot(opts)
  }

  function sub(prefix, opts) {
    return state.bee.sub(prefix, opts)
  }

  function batch(opts) {
    return state.bee.batch(opts)
  }

  async function add_writer(key, is_indexer = true) {
    const key_str = typeof key === 'string' ? key : key.toString('hex')
    await state.base.append({ type: 'add_writer', data: { key: key_str, is_indexer } })
    await state.base.update()
  }

  async function update() {
    return state.base.update()
  }

  function replicate(stream_or_initiator, opts = {}) {
    return state.store.replicate(stream_or_initiator, opts)
  }
}

// ============================================================================
// GENERAL HELPER FUNCTIONS
// ============================================================================

/***************************************
MAKE EMITTER
***************************************/
function make_emitter(state = {}) {
  return { on, off, emit }
  function on(type, callback) { (state[type] = state[type] || []).push(callback) }
  function off(type, callback) { (state[type] = state[type] || [])[state[type].indexOf(callback)] = undefined }
  function emit(type, data) {
    function handle_callback(f) {
      return f && f(data)
    }
    return (state[type] = state[type] || []).map(handle_callback)
  }
}