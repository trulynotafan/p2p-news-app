// P2P News App Networking
// App-specific swarm + protomux protocol for peer discovery and data exchange
const c = require('compact-encoding')
const b4a = require('b4a')
const Protomux = require('protomux')
const Hyperswarm = require('hyperswarm')
const DHT = require('@hyperswarm/dht-relay')
const Stream = require('@hyperswarm/dht-relay/ws')
const HyperWebRTC = require('hyper-webrtc')

module.exports = { start_app_networking }

const is_cli = typeof globalThis.open === 'undefined'

/***************************************
Start app networking
***************************************/

async function start_app_networking (store, opts = {}) {
  const { topic, get_username, get_primary_key } = opts
  await store.ready()

  const swarm = await create_swarm(store)
  swarm.on('connection', (socket) => {
    if (!socket.userData) socket.userData = null
    setup_protocol(socket, { store, is_cli, get_username, get_primary_key })
  })
  swarm.join(topic, { server: true, client: true })
  console.log('p2p-news-app: Swarm Joined')
  return { swarm }
}

/***************************************
Create Swarm
***************************************/

async function create_swarm (store) {
  if (is_cli) {
    const swarm = new Hyperswarm()
    store.swarm = swarm
    return swarm
  }

  const is_dev = location.hostname === 'localhost' || location.hostname.startsWith('192.') || location.hostname.startsWith('10.')
  const relay_url = is_dev ? 'ws://localhost:8080' : 'wss://relay-production-9c0e.up.railway.app'

  return new Promise((resolve, reject) => {
    const socket = new WebSocket(relay_url)
    const resolved = { value: false }

    function on_error (err) {
      if (resolved.value) return
      resolved.value = true
      reject(new Error(`Relay failed: ${relay_url} - ${err?.message || 'Connection error'}`))
    }

    socket.addEventListener('error', on_error)
    socket.addEventListener('close', on_error)
    socket.addEventListener('open', async () => {
      try {
        if (resolved.value) return
        resolved.value = true
        const stream = new Stream(true, socket)
        const dht = new DHT(stream)
        const swarm = new Hyperswarm({ dht })
        store.swarm = swarm
        resolve(swarm)
      } catch (e) { reject(e) }
    })
  })
}

/***************************************
PROTOCOL SETUP
***************************************/
function setup_protocol (socket, opts) {
  const { store, is_cli, get_username, get_primary_key } = opts
  const mux = new Protomux(socket)
  const name = get_username ? get_username() : 'unknown'
  const mode = is_cli ? 'native' : 'browser'

  const channel = mux.createChannel({ protocol: 'identity-exchange', onopen })
  channel.open()

  // CLI replicates on the raw socket, browser replicates per-protocol
  // @todo, add proper sandboxing and not replicate the entire store.
  if (is_cli) store.replicate(socket)

  let message
  function onopen () {
    message = channel.addMessage({ encoding: c.json, onmessage })
    // Send our identity
    message.send({ type: 'protocol', data: { name, mode } })
    // Send feedkey if available
    const key = get_primary_key ? get_primary_key() : null
    if (key) message.send({ type: 'feedkey', data: key })
  }

  let has_received_key = false
  async function onmessage (msg) {
    try {
      if (msg.type === 'protocol' && msg.data?.name) {
        console.log(`Discovered peer: ${msg.data.name}`)
        // Browser-to-native: replicate on the relay socket
        if (!is_cli && msg.data.mode === 'native') {
          const key = get_primary_key ? get_primary_key() : null
          if (key) message.send({ type: 'feedkey', data: key })
          // @todo, add proper sandboxing and not replicate the entire store.
          store.replicate(socket)
        }
        // Browser-to-browser: upgrade to WebRTC
        if (!is_cli && msg.data.mode === 'browser') {
          const rtc = HyperWebRTC.from(socket, { initiator: socket.isInitiator })
          rtc.on('open', () => {
            console.log('[p2p-news-app] WebRTC connection established')
            const key = get_primary_key ? get_primary_key() : null
            if (key) message.send({ type: 'feedkey', data: key })
            store.replicate(rtc)
          })
          rtc.on('error', (err) => {
            if (!err?.message?.includes('Abort') && !err?.message?.includes('closed')) {
              console.warn('WebRTC error:', err?.message)
            }
          })
        }
      }
      if (msg.type === 'feedkey' && !has_received_key) {
        has_received_key = true
        const key_buffer = b4a.from(msg.data, 'hex')
        if (key_buffer?.length === 32) {
          store.emit('peer-autobase-key', { key: b4a.toString(key_buffer, 'hex'), key_buffer })
        }
      }
    } catch (err) {
      console.error('Protocol error:', err)
    }
  }
}
