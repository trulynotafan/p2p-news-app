// Networking module - handles P2P network setup
// Creates corestore, swarm, and connection handlers for both CLI and browser
const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const Protomux = require('protomux')
const { create_mnemonic_keypair, save, load: load_mnemonic } = require('crypto-helpers')
const { identity_exchange_protocol, create_cli_protocol_handlers, create_browser_protocol_handlers } = require('identity-protocol-helpers')

const is_cli = typeof globalThis.open === 'undefined'
const RAW = is_cli ? null : require('random-access-web')
const DHT = require('@hyperswarm/dht-relay')
const Stream = require('@hyperswarm/dht-relay/ws')
const HyperWebRTC = is_cli ? null : require('hyper-webrtc')

module.exports = { start_networking }

/***************************************
START NETWORKING
***************************************/
async function start_networking (options = {}) {
  const name = options.name || 'peer'
  const topic = options.topic
  const store_name = options.store_name || name
  const get_primary_key = options.get_primary_key
  const get_primary_structure = options.get_primary_structure
  if (!topic) {
    throw new Error('start_networking requires a topic parameter')
  }
  const store = is_cli
    ? new Corestore(`./storage-${store_name}`)
    : new Corestore(RAW(store_name))
  await store.ready()
  if (options.offline_mode) {
    return { store, swarm: null, dht: null, cleanup: () => { } }
  }
  if (is_cli) {
    const seedphrase = await load_mnemonic(name)
    const mnemonic_data = seedphrase
      ? await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise', mnemonic: seedphrase })
      : await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise' })
    if (!seedphrase) await save(mnemonic_data.mnemonic, name)
    const swarm = new Hyperswarm({ key_pair: mnemonic_data.keypair })
    swarm.on('connection', create_cli_connection_handler({ store, name, get_primary_key, keypair: mnemonic_data.keypair }))
    swarm.join(topic, { server: true, client: true })
    store.swarm = swarm
    return { store, swarm, dht: null, cleanup: () => swarm.destroy() }
  }
  const is_dev = location.hostname === 'localhost' || location.hostname.startsWith('192.') || location.hostname.startsWith('10.')
  const relay_url = options.relay || (is_dev ? 'ws://localhost:8080' : 'wss://relay-production-9c0e.up.railway.app')
  console.log('[Identity] Using relay:', relay_url)
  await store.ready()
  return new Promise(init_socket)
  function init_socket (resolve, reject) {
    const socket = new WebSocket(relay_url)
    const resolved_state = { value: false }
    const error_handler = create_socket_error_handler({ resolved_state, relay_url, reject })
    socket.addEventListener('error', error_handler)
    socket.addEventListener('close', error_handler)
    socket.addEventListener('open', create_socket_open_handler({
      socket,
      resolved_state,
      name,
      relay_url,
      topic,
      store,
      get_primary_key,
      get_primary_structure,
      resolve,
      reject
    }))
  }
}

/***************************************
CREATE CLI CONNECTION HANDLER
***************************************/
function create_cli_connection_handler (config) {
  const { store, name, get_primary_key, keypair } = config
  return function handle_cli_connection (socket, info) {
    const peer_id = info.publicKey.toString('hex')
    console.log(`Connected to peer: ${peer_id.slice(0, 8)}`)
    const mux = new Protomux(socket)
    const { handlers, init_fn } = create_cli_protocol_handlers({ store, name, get_primary_key })
    const setup_protocol = identity_exchange_protocol(handlers, (send) => init_fn(send, keypair), {
      peer_mode: 'native',
      label: '[CLI]'
    })
    const channel = setup_protocol(mux)
    channel.open()
    store.replicate(socket)
  }
}

/***************************************
CREATE BROWSER CONNECTION HANDLER
***************************************/
function create_browser_connection_handler (config) {
  const { store, name, relay_url, mnemonic_data, get_primary_key, get_primary_structure, HyperWebRTC } = config
  return function handle_browser_connection (relay, details) {
    if (!relay.userData) relay.userData = null
    const mux = new Protomux(relay)
    const { handlers, init_fn } = create_browser_protocol_handlers({
      store, relay, name, relay_url, mnemonic_data, get_primary_key, HyperWebRTC
    })
    const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
      peer_mode: 'browser',
      label: '[browser-peer]'
    })
    const identity_channel = setup_protocol(mux)
    identity_channel.open()
    store.on('peer-add', handle_peer_add)
    relay.on('error', handle_relay_error)
    function handle_peer_add (peer) {
      if (get_primary_structure) {
        const structure = get_primary_structure()
        if (structure && structure.key) {
          store.emit('peer-autobase-key', {
            key: b4a.toString(structure.key, 'hex'),
            key_buffer: structure.key
          })
        }
      }
    }
    function handle_relay_error (err) {
      if (!err.message?.includes('Duplicate connection')) {
        console.warn('Relay error:', err.message)
      }
    }
  }
}

/***************************************
CREATE SOCKET ERROR HANDLER
***************************************/
function create_socket_error_handler (config) {
  const { resolved_state, relay_url, reject } = config
  return function handle_socket_error (err) {
    if (resolved_state.value) return
    resolved_state.value = true
    const message = err?.message || 'Connection error'
    reject(new Error(`Relay connection failed: ${relay_url} - ${message}`))
  }
}

/***************************************
CREATE SOCKET OPEN HANDLER
***************************************/
function create_socket_open_handler (config) {
  const { socket, resolved_state, name, relay_url, topic, store, get_primary_key, get_primary_structure, resolve, reject } = config
  return async function handle_socket_open () {
    try {
      if (resolved_state.value) return
      resolved_state.value = true
      if (socket.readyState !== WebSocket.OPEN) {
        console.error('Socket not ready:', socket.readyState)
        return
      }
      const seedphrase = await load_mnemonic(name)
      const mnemonic_data = seedphrase
        ? await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise', mnemonic: seedphrase })
        : await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise' })
      if (!seedphrase) await save(mnemonic_data.mnemonic, name)
      const stream = new Stream(true, socket)
      const dht = new DHT(stream)
      const swarm = new Hyperswarm({ dht, key_pair: mnemonic_data.keypair })
      swarm.on('connection', create_browser_connection_handler({
        store,
        name,
        relay_url,
        mnemonic_data: mnemonic_data.keypair,
        get_primary_key,
        get_primary_structure,
        HyperWebRTC
      }))
      console.log('Joining swarm')
      const discovery = swarm.join(topic, { server: true, client: true })
      const join_interval = setInterval(() => {
        swarm.join(topic, { server: true, client: true })
          .flushed()
          .catch((err) => console.warn('Join warning:', err.message))
      }, 5000)
      store.swarm = swarm
      resolve({ store, swarm, dht, cleanup: () => clearInterval(join_interval) })
      discovery.flushed()
        .then(() => console.log('Swarm joined'))
        .catch((err) => console.warn('Flush warning:', err.message))
    } catch (error) {
      console.error('Error in socket open handler:', error)
      reject(error)
    }
  }
}
