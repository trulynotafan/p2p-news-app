const Autobase = require('autobase')
const b4a = require('b4a')
const { Readable } = require('streamx')

module.exports = { create_auditcore }

function create_auditcore (options) {
  const { store, bootstrap, opts = {} } = options
  const emitter = make_emitter()
  const state = { store, bootstrap, opts, base: null, entries: [] }

  state.base = new Autobase(store, bootstrap, {
    valueEncoding: 'json',
    open: handle_autobase_open,
    apply: handle_autobase_apply,
    ackInterval: opts.ack_interval || 1000,
    ackThreshold: opts.ack_threshold || 1,
    fastForward: false
  })

  state.base.on('update', handle_base_update)

  function handle_base_update () {
    if (state.base.view && state.base.view.entries) {
      state.entries = state.base.view.entries
    }
    emitter.emit('update')
  }

  const api = {
    get base () { return state.base },
    get key () { return state.base ? state.base.key : null },
    get writable () { return state.base ? state.base.writable : false },
    get length () { return state.entries.length },
    on,
    off,
    ready,
    close,
    append,
    get,
    read,
    get_by_type,
    get_by_device,
    create_read_stream,
    add_writer,
    remove_writer,
    update,
    replicate
  }

  return api

  /***************************************
INTERNAL FUNCTIONS
***************************************/
  function on (event, listener) {
    emitter.on(event, listener)
  }

  function off (event, listener) {
    emitter.off(event, listener)
  }

  async function ready () {
    await state.base.ready()
    await state.base.update()
    if (state.base.view && state.base.view.entries) {
      state.entries = state.base.view.entries
    }
  }

  async function close () {
    if (state.base) await state.base.close()
  }

  async function append (entry) {
    if (!entry.type) throw new Error('Entry must have a type')
    const full_entry = {
      type: entry.type,
      data: {
        ...entry.data || {},
        timestamp: Date.now()
      }
    }
    await state.base.append(full_entry)
    await state.base.update()
    return state.entries.length - 1
  }

  async function get (seq) {
    if (seq < 0 || seq >= state.entries.length) return null
    return state.entries[seq]
  }

  async function read (start = 0, end) {
    const stop = end !== undefined ? Math.min(end, state.entries.length) : state.entries.length
    return state.entries.slice(start, stop)
  }

  async function get_by_type (type) {
    return state.entries.filter(function (e) {
      return e.type === type
    })
  }

  async function get_by_device (device_id) {
    return state.entries.filter(function (e) {
      return e.data && e.data.device_id === device_id
    })
  }

  function create_read_stream (opts = {}) {
    const entries = state.entries
    let index = opts.start || 0
    const end = opts.end !== undefined ? Math.min(opts.end, entries.length) : entries.length
    return new Readable({
      read (cb) {
        if (index >= end) {
          this.push(null)
        } else {
          this.push(entries[index++])
        }
        cb(null)
      }
    })
  }

  async function add_writer (key, is_indexer = true) {
    const key_str = typeof key === 'string' ? key : key.toString('hex')
    await state.base.append({ type: 'add_writer', data: { key: key_str, is_indexer } })
    await state.base.update()
  }

  async function remove_writer (key) {
    const key_str = typeof key === 'string' ? key : key.toString('hex')
    await state.base.append({ type: 'remove_writer', data: { key: key_str } })
    await state.base.update()
  }

  async function update () {
    return state.base.update()
  }

  function replicate (stream_or_initiator, opts = {}) {
    return state.store.replicate(stream_or_initiator, opts)
  }
}

/***************************************
GENERAL HELPER FUNCTIONS
***************************************/

/***************************************
HANDLE AUTOBASE OPEN
***************************************/
function handle_autobase_open (store) {
  const audit_store = store.base.store.namespace('auditcore')
  const core = audit_store.get({ name: 'log' })
  return { core, entries: [] }
}

/***************************************
HANDLE AUTOBASE APPLY
***************************************/
async function handle_autobase_apply (nodes, view, base) {
  for (const node of nodes) {
    if (node.value === null) continue
    const { type, data } = node.value
    if (type === 'add_writer') {
      await base.addWriter(b4a.from(data.key, 'hex'), { indexer: data.is_indexer })
    } else if (type === 'remove_writer') {
      await base.removeWriter(b4a.from(data.key, 'hex'))
    } else {
      view.entries.push(node.value)
    }
  }
}

/***************************************
MAKE EMITTER
***************************************/
function make_emitter (state = {}) {
  return { on, off, emit }
  function on (type, callback) { (state[type] = state[type] || []).push(callback) }
  function off (type, callback) { (state[type] = state[type] || [])[state[type].indexOf(callback)] = undefined }
  function emit (type, data) {
    function handle_callback (f) {
      return f && f(data)
    }
    return (state[type] = state[type] || []).map(handle_callback)
  }
}
