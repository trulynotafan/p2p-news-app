const b4a = require('b4a')
const sodium = require('sodium')
const bip39 = require('bip39-mnemonic')

module.exports = {
  create_mnemonic_keypair,
  get_or_create_keypair,
  save,
  load
}

// Load existing mnemonic or create new one, save it, and return keypair data
async function get_or_create_keypair (storage_name = 'vault') {
  const seedphrase = await load(storage_name)
  const mnemonic_data = seedphrase
    ? await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise', mnemonic: seedphrase })
    : await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise' })
  if (!seedphrase) await save(mnemonic_data.mnemonic, storage_name)
  return mnemonic_data
}

const isBrowser = (typeof window !== 'undefined')

// Save/load functions for seedphrase
async function save (seedphrase, name = 'default') {
  if (isBrowser) {
    localStorage[`${name}-seedphrase`] = seedphrase
  } else {
    // Use dynamic require to avoid browserify trying to bundle bare-fs
    const fs = eval('require')('bare-fs')
    await fs.promises.writeFile(`.${name}-seedphrase`, seedphrase, 'utf8')
  }
}

async function load (name = 'default') {
  if (isBrowser) {
    return localStorage[`${name}-seedphrase`] || null
  } else {
    // Use dynamic require to avoid browserify trying to bundle bare-fs
    const fs = eval('require')('bare-fs')
    try {
      return await fs.promises.readFile(`.${name}-seedphrase`, 'utf8')
    } catch (err) {
      return null
    }
  }
}

// Normalize mnemonicToSeed to always be async and return Buffer
async function mnemonicToSeed (mnemonic) {
  return await bip39.mnemonicToSeed(mnemonic)
}

// Create a keypair from a mnemonic (or generate one if not provided)
async function create_mnemonic_keypair (options = {}) {
  const mnemonic = options.mnemonic || bip39.generateMnemonic(128)
  const seed64 = await mnemonicToSeed(mnemonic)
  const seed32 = seed64.slice(0, 32)
  const publicKey = b4a.alloc(32)
  const secretKey = b4a.alloc(64)
  sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed32)
  return {
    mnemonic,
    seed: seed32,
    keypair: { publicKey, secretKey }
  }
}
