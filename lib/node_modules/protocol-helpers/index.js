const c = require('compact-encoding')
const b4a = require('b4a')

// Protocol helpers for identity exchange between peers
// Handles protocol negotiation and feedkey exchange

module.exports = { identity_exchange_protocol, create_cli_protocol_handlers, create_browser_protocol_handlers }

/***************************************
IDENTITY EXCHANGE PROTOCOL
***************************************/
function identity_exchange_protocol (handlers, init_fn, options = {}) {
  const { peer_mode = 'unknown', label = '[peer]' } = options

  return function (mux) {
    let has_received_key = false

    const channel = mux.createChannel({
      protocol: 'identity-exchange',
      onopen: () => {
        console.log(label, 'Identity channel opened')

        const message = channel.addMessage({
          encoding: c.json,
          onmessage: async (msg) => {
            try {
              // Handle protocol message
              if (msg.type === 'protocol') {
                if (handlers.on_protocol) {
                  await handlers.on_protocol(msg, m => message.send(m), peer_mode)
                }
              }

              // Handle feedkey message
              if (msg.type === 'feedkey' && !has_received_key) {
                has_received_key = true
                const key_buffer = b4a.from(msg.data, 'hex')

                if (!key_buffer || key_buffer.length !== 32) {
                  console.error('Invalid feed key:', msg.data)
                  return
                }

                if (handlers.on_feedkey) {
                  await handlers.on_feedkey({
                    key_buffer,
                    hex_key: key_buffer.toString('hex'),
                    message: msg
                  }, m => message.send(m))
                }
              }
            } catch (err) {
              console.error(label, 'Error handling message:', err)
            }
          }
        })

        if (init_fn) init_fn(m => message.send(m))
      }
    })

    return channel
  }
}

/***************************************
CREATE CLI PROTOCOL HANDLERS
***************************************/
function create_cli_protocol_handlers (store, name, get_primary_key) {
  return {
    handlers: {
      on_protocol: async (message, send) => {
        if (message.data && message.data.name) {
          console.log(`Discovered peer: ${message.data.name}`)
        }
      },
      on_feedkey: async ({ key_buffer }) => {
        const hex_key = b4a.toString(key_buffer, 'hex')
        console.log(`Received key: ${hex_key.slice(0, 8)}`)
        store.emit('peer-autobase-key', { key: hex_key, key_buffer })
      }
    },
    init_fn: function handle_protocol_init (send, mnemonic_data) {
      send({
        type: 'protocol',
        data: {
          name: name,
          mode: 'native',
          device_public_key: mnemonic_data.publicKey.toString('hex')
        }
      })

      if (get_primary_key) {
        const key = get_primary_key()
        if (key) send({ type: 'feedkey', data: key })
      }
    }
  }
}

/***************************************
CREATE BROWSER PROTOCOL HANDLERS
***************************************/
function create_browser_protocol_handlers (config) {
  const { store, relay, name, relay_url, mnemonic_data, get_primary_key, HyperWebRTC } = config
  const peer_relay_url_state = { url: null }

  return {
    handlers: {
      on_protocol: async function handle_protocol_message (message, send, current_peer_mode) {
        if (message.data.relay_url) {
          peer_relay_url_state.url = message.data.relay_url
          if (!window.discovered_relays) window.discovered_relays = new Set()
          window.discovered_relays.add(message.data.relay_url)
        }

        if (message.data.mode === 'browser' && current_peer_mode === 'browser') {
          const stream = HyperWebRTC.from(relay, { initiator: relay.isInitiator })

          stream.on('open', () => {
            console.log('WebRTC connection established')
            const primary_key = get_primary_key ? get_primary_key() : null
            if (primary_key) send({ type: 'feedkey', data: primary_key })
            store.replicate(stream)
          })

          stream.on('error', (err) => {
            if (!err || (!err.message?.includes('Abort') && !err.message?.includes('closed'))) {
              console.warn('WebRTC error details:', {
                message: err?.message,
                code: err?.code,
                stack: err?.stack,
                fullError: err
              })
            }
          })
        } else if (message.data.mode === 'native') {
          const primary_key = get_primary_key ? get_primary_key() : null
          if (primary_key) send({ type: 'feedkey', data: primary_key })
          store.replicate(relay)
        }
      },
      on_feedkey: async function handle_feedkey_message ({ key_buffer }) {
        const hex_key = b4a.toString(key_buffer, 'hex')
        store.emit('peer-autobase-key', { key: hex_key, key_buffer, relay_url: peer_relay_url_state.url })
      }
    },
    init_fn: function handle_protocol_init (send) {
      send({
        type: 'protocol',
        data: {
          name,
          mode: 'browser',
          device_public_key: b4a.toString(mnemonic_data.publicKey, 'hex'),
          relay_url: relay_url
        }
      })
    }
  }
}
