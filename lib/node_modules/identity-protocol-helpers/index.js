const c = require('compact-encoding')
const b4a = require('b4a')

// Protocol helpers for identity exchange between peers
// Handles protocol negotiation and feedkey exchange

module.exports = { identity_exchange_protocol, create_cli_protocol_handlers, create_browser_protocol_handlers }

/***************************************
IDENTITY EXCHANGE PROTOCOL
***************************************/
function identity_exchange_protocol (handlers, init_fn, options = {}) {
  const { peer_mode = 'unknown', label = '[peer]' } = options

  return function (mux) {
    let has_received_key = false
    let message = null

    const channel = mux.createChannel({
      protocol: 'identity-exchange',
      onopen: () => handle_channel_open()
    })
    return channel

    function handle_channel_open () {
      console.log(label, 'Identity channel opened')
      message = channel.addMessage({
        encoding: c.json,
        onmessage: (msg) => handle_identity_message(msg)
      })
      if (init_fn) init_fn(m => message.send(m))
    }

    async function handle_identity_message (msg) {
      try {
        // Handle protocol message
        if (msg.type === 'protocol') {
          if (handlers.on_protocol) {
            await handlers.on_protocol(msg, m => message.send(m), peer_mode)
          }
        }
        // Handle feedkey message
        if (msg.type === 'feedkey' && !has_received_key) {
          has_received_key = true
          const key_buffer = b4a.from(msg.data, 'hex')
          if (!key_buffer || key_buffer.length !== 32) {
            console.error('Invalid feed key:', msg.data)
            return
          }
          if (handlers.on_feedkey) {
            await handlers.on_feedkey({
              key_buffer,
              hex_key: key_buffer.toString('hex'),
              message: msg
            }, m => message.send(m))
          }
        }
      } catch (err) {
        console.error(label, 'Error handling message:', err)
      }
    }
  }
}

/***************************************
CREATE CLI PROTOCOL HANDLERS
***************************************/
function create_cli_protocol_handlers (config) {
  const { store, name, get_primary_key } = config
  return {
    handlers: { on_protocol: handle_protocol_message, on_feedkey: handle_feedkey_message },
    init_fn: handle_protocol_init
  }

  async function handle_protocol_message (message, send) {
    if (message.data && message.data.name) {
      console.log(`Discovered peer: ${message.data.name}`)
    }
  }

  async function handle_feedkey_message ({ key_buffer }) {
    const hex_key = b4a.toString(key_buffer, 'hex')
    console.log(`Received key: ${hex_key.slice(0, 8)}`)
    store.emit('peer-autobase-key', { key: hex_key, key_buffer })
  }

  function handle_protocol_init (send, mnemonic_data) {
    send({
      type: 'protocol',
      data: {
        name: name,
        mode: 'native',
        device_public_key: mnemonic_data.publicKey.toString('hex')
      }
    })
    if (get_primary_key) {
      const key = get_primary_key()
      if (key) send({ type: 'feedkey', data: key })
    }
  }
}

/***************************************
CREATE BROWSER PROTOCOL HANDLERS
***************************************/
function create_browser_protocol_handlers (config) {
  const { store, relay, name, relay_url, mnemonic_data, get_primary_key, HyperWebRTC } = config
  const peer_relay_url_state = { url: null }

  return {
    handlers: { on_protocol: handle_protocol_message, on_feedkey: handle_feedkey_message },
    init_fn: handle_protocol_init
  }

  async function handle_feedkey_message ({ key_buffer }) {
    const hex_key = b4a.toString(key_buffer, 'hex')
    store.emit('peer-autobase-key', { key: hex_key, key_buffer, relay_url: peer_relay_url_state.url })
  }

  function handle_protocol_init (send) {
    send({
      type: 'protocol',
      data: {
        name,
        mode: 'browser',
        device_public_key: b4a.toString(mnemonic_data.publicKey, 'hex'),
        relay_url: relay_url
      }
    })
  }

  async function handle_protocol_message (message, send, current_peer_mode) {
    if (message.data.relay_url) {
      peer_relay_url_state.url = message.data.relay_url
      if (!peer_relay_url_state.discovered_relays) peer_relay_url_state.discovered_relays = new Set()
      peer_relay_url_state.discovered_relays.add(message.data.relay_url)
    }
    if (message.data.mode === 'browser' && current_peer_mode === 'browser') {
      const stream = HyperWebRTC.from(relay, { initiator: relay.isInitiator })
      const opts = { store, stream, send }
      stream.on('open', () => on_stream_open(opts))
      stream.on('error', on_stream_error)
    } else if (message.data.mode === 'native') {
      const primary_key = get_primary_key ? get_primary_key() : null
      if (primary_key) send({ type: 'feedkey', data: primary_key })
      store.replicate(relay)
    }
  }

  function on_stream_error (err) {
    if (!err || (!err.message?.includes('Abort') && !err.message?.includes('closed'))) {
      console.warn('WebRTC error details:', {
        message: err?.message,
        code: err?.code,
        stack: err?.stack,
        fullError: err
      })
    }
  }

  function on_stream_open ({ store, stream, send }) {
    console.log('WebRTC connection established')
    const primary_key = get_primary_key ? get_primary_key() : null
    if (primary_key) send({ type: 'feedkey', data: primary_key })
    store.replicate(stream)
  }
}