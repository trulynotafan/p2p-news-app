// P2P News App.. Blog application that receives identity (vault) as parameter
// Exports a single constructor function named blog_app
const b4a = require('b4a')

// Blog-specific topic for swarm discovery
const BLOG_TOPIC = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

// App ID for vault registration
const APP_ID = 'p2p-news-app'

module.exports = blog_app

function blog_app (identity) {
  // identity is the vault object from the identity module

  /***************************************
DATA STRUCTURES, The only place we need to define structures..
***************************************/
  // To add a new structure just add ONE line here:
  // - name: identifier for the structure (e.g., 'comments', 'likes', 'media')
  // - namespace: storage namespace (e.g., 'blog-comments', 'chat-messages')
  // - type: 'autobase' for structured data, 'autodrive' for files (Both are multidevice obviously)
  // - encoding: (autobase only) 'json' or something else
  // - view_name: (autobase only) name for the view hypercore
  //
  // The datastructure-manager handles this automatically:
  // registration, initialization, pairing, replication,  writer management
  const STRUCTURES = [
    { name: 'metadata', namespace: 'blog-metadata', type: 'autobase', encoding: 'json', view_name: 'blog-view' },
    { name: 'drive', namespace: 'blog-files', type: 'autodrive' },
    { name: 'profile', namespace: 'blog-profile', type: 'autodrive' },
    { name: 'events', namespace: 'blog-events', type: 'autodrive' }
  // ADD NEW STRUCTURES, Just one line. Example:
  // { name: 'comments', namespace: 'blog-comments', type: 'autodrive' }
  ]

  // Global state
  let store; let ds_manager; let pairing_manager; const pairing_result = null
  const discovered_blogs = new Map()
  const peer_relays = new Map() // Store relay URLs for peers
  const autobase_cache = new Map()
  const drive_cache = new Map()
  const emitter = make_emitter()

  // Return the blog app API
  const api = {
    init_blog,
    create_post,
    create_invite,
    verify_pairing,
    deny_pairing,
    subscribe,
    unsubscribe,
    get_blog_username,
    get_blog_profile_drive_key,
    get_blog_events_drive_key,
    get_my_posts,
    get_peer_blogs,
    // Profile management
    get_profile,
    get_avatar_content,
    upload_avatar,
    create_default_profile,
    // Device/pairing management
    log_event,
    get_paired_devices,
    remove_device,
    get_raw_data,
    // Relay management
    set_peer_relay,
    // Other getters
    get_local_key,
    get_drive,
    get_profile_drive,
    get_autobase_key,
    get_autobase,
    get_metadata_store,
    get_drive_store,
    get_profile_store,
    get_events_store,
    get_discovered_blogs,
    on_update: (cb) => emitter.on('update', cb),
    get_app_audit_log_entries
  }
  return api

  /***************************************
INTERNAL FUNCTIONS
***************************************/

  // Audit logging helper - uses vault-managed app auditcore
  async function audit_log (op, data = {}) {
    const app_audit = identity.get_app_audit(APP_ID)
    if (app_audit) await app_audit.append({ type: op, data })
  }

  // Store relay URL for a peer (called from protocol exchange)
  function set_peer_relay (key, relay_url) {
    if (relay_url) peer_relays.set(key, relay_url)
  }

  // Setup peer autobase
  async function setup_peer_autobase (key, key_buffer) {
    // Check if already exists
    if (autobase_cache.has(key)) return autobase_cache.get(key)
    // Use datastructure-manager to create peer metadata autobase
    const peer_autobase = await ds_manager.create_peer_structure({ name: 'metadata', peer_key: key, peer_key_buffer: key_buffer, store_instance: store })
    // Wait for data if empty
    if (peer_autobase.view.length === 0) {
      await new Promise(resolve => peer_autobase.once('update', resolve))
    }
    async function handle_peer_autobase_update () {
      if (peer_autobase.view.length > 0) {
        try {
          const init_raw_data = await peer_autobase.view.get(0)
          const init_entry = JSON.parse(init_raw_data)
          if (validate_blog_init(init_entry)) {
            discovered_blogs.set(key, {
              username: init_entry.data.username,
              title: init_entry.data.title,
              drive_key: init_entry.data.drive_key,
              relay_url: peer_relays.get(key) || null
            })
            // Setup peer drive
            if (!drive_cache.has(key) && init_entry.data.drive_key) {
              const drive_key_buffer = b4a.from(init_entry.data.drive_key, 'hex')
              const peer_drive = await ds_manager.create_peer_structure({ name: 'drive', peer_key: key, peer_key_buffer: drive_key_buffer, store_instance: store })
              drive_cache.set(key, peer_drive)
            }
            emitter.emit('update')
          }
        } catch (err) {
          console.error('[setup_peer_autobase] Error processing update:', err)
        }
      }
    }
    peer_autobase.on('update', handle_peer_autobase_update)
    await handle_peer_autobase_update()
    autobase_cache.set(key, peer_autobase)
    return peer_autobase
  }

  // Restore subscribed peers
  function restore_subscribed_peers () {
    if (!store) return
    async function handle_peer_key (key) {
      try {
        const key_buffer = b4a.from(key, 'hex')
        await setup_peer_autobase(key, key_buffer)
      } catch (err) {
        console.error('Error restoring peer:', err)
      }
    }
    get_subscribed_peers().forEach(handle_peer_key)
  }

  // VAULT REGISTRATION - Register app structures with vault on init
  async function register_app_with_vault () {
    const vault_bee = identity.get_vault_bee()
    // Get structure keys for registration
    const structure_keys = {}
    for (const config of STRUCTURES) {
      const key = ds_manager.get_key(config.name)
      if (key) {
        structure_keys[config.name] = key
      }
    }
    // Register app with vault (vault auto-creates auditcore and links it)
    await identity.register_app(APP_ID, {
      name: 'P2P News App',
      structures: STRUCTURES.map(s => ({
        name: s.name,
        namespace: s.namespace,
        type: s.type,
        key: structure_keys[s.name]
      }))
    })
  }

  // WRITER KEY WATCHER - Watch vault for writer key requests from paired devices
  async function start_writer_watcher () {
    const vault_bee = identity.get_vault_bee()
    if (!vault_bee) return
    const watcher = vault_bee.watch({ gte: `writer_requests/${APP_ID}`, lt: `writer_requests/${APP_ID}0` })
    // Start watching for writer requests
    // Next commit i'll move it to vault code.
    watch_writer_requests(watcher)
    async function watch_writer_requests (watcher) {
      for await (const _ of watcher) {
        await process_writer_requests()
      }
    }
    async function process_writer_requests () {
      const requests = await identity.vault_get(`writer_requests/${APP_ID}`)
      if (!requests) return
      let processed_any = false
      for (const req of requests) {
        if (req.processed) continue
        processed_any = true
        await add_writers_from_request(req)
        await mark_request_processed(req)
        await log_device_pairing(req)
      }
      if (processed_any) {
        await identity.vault_put(`writer_requests/${APP_ID}`, requests)
        emitter.emit('update')
      }
    }
    async function add_writers_from_request (req) {
      for (const [name, key] of Object.entries(req.writer_keys)) {
        try {
          if (name === 'app_audit') {
            // App audit is managed by vault, not ds_manager
            // This is so that pairing device gets writer access for app audit as well
            // @TODO Move watchers to core identity.
            const app_audit = identity.get_app_audit(APP_ID)
            if (app_audit) await app_audit.add_writer(key)
          } else {
            await ds_manager.add_writer(name, key)
          }
          console.log(`[p2p-news-app] Added writer to ${name}:`, key)
        } catch (err) {
          console.error(`[p2p-news-app] Failed to add writer to ${name}:`, err.message)
        }
      }
    }
    function mark_request_processed (req) {
      req.processed = true
      req.processed_at = Date.now()
    }
    async function log_device_pairing (req) {
      // Log Aux Device as a paired device with all its writer keys
      const device_keys = {}
      for (const [name, key] of Object.entries(req.writer_keys)) {
        device_keys[`${name}_writer`] = key
      }
      await log_event('add', device_keys)
    }
  }

  // Initialize blog
  async function init_blog (options) {
    const { username, relay, offline_mode } = options
    // Check if vault already exists (pair mode)
    const vault_bee = identity.get_vault_bee()
    const network_store = identity.get_network_store()
    const swarm_instance = identity.get_swarm()
    if (vault_bee && network_store && swarm_instance) {
      store = network_store
      ds_manager = identity.create_ds_manager()
      identity.set_ds_manager(ds_manager)
      const app = await identity.get_app(APP_ID)
      if (!app?.structures) throw new Error('Could not sync with vault. Make sure Device A is online.')
      const keys_map = Object.fromEntries(app.structures.filter(s => s.key).map(s => [s.name, s.key]))
      await ds_manager.init_all(STRUCTURES.map(c => ({ ...c, store })), keys_map)
      // Load the vault-managed app auditcore if it exists (menaing this is for pairing device)
      if (app.audit_key) await identity.load_app_audit(APP_ID, app.audit_key)
      await request_app_writer_access()
      await wait_for_writer_access()
      identity.set_events_drive(ds_manager.get('events'), ds_manager.get_store('events'))
      setup_peer_handlers()
      return { store, swarm: swarm_instance }
    }
    // SEED MODE: Start networking, create vault, then app structures
    const networking_options = {
      name: username,
      store_name: `storage-${username}`,
      topic: BLOG_TOPIC,
      get_primary_key: () => ds_manager ? ds_manager.get_key('metadata') : null,
      get_primary_structure: () => ds_manager ? ds_manager.get('metadata') : null,
      relay,
      offline_mode
    }
    const { store: _store, swarm: _swarm } = await identity.start_networking(networking_options)
    store = _store
    identity.set_swarm(_swarm)
    // Create vault structures in this store
    await identity.init_vault_structures({ store, vault_bee_key: null, vault_audit_key: null })
    // Now create app structures
    ds_manager = identity.create_ds_manager()
    identity.set_ds_manager(ds_manager)
    await ds_manager.init_all(STRUCTURES.map(c => ({ ...c, store })))
    const metadata = ds_manager.get('metadata')
    await metadata.append({
      type: 'blog-init',
      data: { username, title: `${username}'s Blog`, drive_key: ds_manager.get_key('drive') }
    })
    await create_default_profile(username)
    await log_bootstrap_device()
    // Register app in vault
    await register_app_with_vault()
    const events_drive = ds_manager.get('events')
    identity.set_events_drive(events_drive, ds_manager.get_store('events'))
    start_writer_watcher()
    setup_peer_handlers()
    return { store, swarm: _swarm }
  }

  // Setup peer discovery handlers
  function setup_peer_handlers () {
    const metadata = ds_manager.get('metadata')
    store.on('peer-autobase-key', async ({ key, key_buffer, relay_url }) => {
      if (key === ds_manager.get_key('metadata')) return
      if (relay_url) set_peer_relay(key, relay_url)
      if (autobase_cache.has(key)) return
      await setup_peer_autobase(key, key_buffer)
    })
    metadata.on('update', () => emitter.emit('update'))
    restore_subscribed_peers()
  }

  // Log bootstrap device with ALL structure writer keys (also dynamic)
  async function log_bootstrap_device () {
    const device_keys = {}
    for (const name of ds_manager.get_names()) {
      const structure = ds_manager.get(name)
      const config = ds_manager.get_config(name)
      let writer_key = null
      if (config.type === 'autobase') {
        writer_key = structure.local?.key
      } else if (config.type === 'autodrive' || config.type === 'auditcore') {
        writer_key = structure.base?.local?.key
      }
      if (writer_key) {
        device_keys[`${name}_writer`] = b4a.toString(writer_key, 'hex')
      }
    }
    const existing_devices = await get_paired_devices()
    const device_exists = existing_devices.some(d => d.metadata_writer === device_keys.metadata_writer)
    if (!device_exists) {
      await log_event('add', device_keys)
    }
  }

  // Create invite
  async function create_invite () {
    const { invite_code, invite } = await identity.create_vault_invite(BLOG_TOPIC)
    const profile = await get_profile()
    pairing_manager = await identity.setup_vault_pairing({
      invite,
      username: profile?.name || 'Unknown',
      on_verification_needed: (digits) => emitter.emit('verification_needed', digits),
      on_paired: async ({ vault_bee_writer, vault_audit_writer }) => {
      // Vault pairing complete - vault keys are handled by identity module
      // Device entries are created when app structures get writer access, not here
        console.log('[p2p-news-app] Vault paired with new device')
        emitter.emit('update')
      }
    })
    return { invite_code, pairing_manager }
  }

  function verify_pairing (code) { return identity.verify_vault_pairing(code) }

  function deny_pairing () {
    identity.deny_vault_pairing()
    emitter.emit('update')
  }

  // Request writer access (Paring Deivce Side)
  async function request_app_writer_access () {
    if (!identity.get_vault_bee()) return
    const writer_keys = {}
    for (const name of ds_manager.get_names()) {
      const key = get_local_writer_key(ds_manager.get(name), ds_manager.get_config(name).type)
      if (key) writer_keys[name] = b4a.toString(key, 'hex')
    }
    // Include app_audit writer key
    const app_audit = identity.get_app_audit(APP_ID)
    if (app_audit) {
      writer_keys.app_audit = b4a.toString(app_audit.base.local.key, 'hex')
    }
    const requests = await identity.vault_get(`writer_requests/${APP_ID}`) || []
    requests.push({ writer_keys, requested_at: Date.now(), processed: false })
    await identity.vault_put(`writer_requests/${APP_ID}`, requests)
    return writer_keys
  }

  // Wait for Device A to process our writer access request
  async function wait_for_writer_access () {
    const vault_bee = identity.get_vault_bee()
    const our_key = ds_manager.get('metadata')?.local?.key
    if (!vault_bee || !our_key) return false
    const our_hex = b4a.toString(our_key, 'hex')
    for await (const _ of vault_bee.watch({ gte: `writer_requests/${APP_ID}`, lt: `writer_requests/${APP_ID}0` })) {
      const reqs = await identity.vault_get(`writer_requests/${APP_ID}`)
      if (reqs?.find(r => r.writer_keys?.metadata === our_hex && r.processed)) return true
    }
  }

  // Create post
  async function create_post (title, content) {
    const drive = ds_manager.get('drive')
    const metadata = ds_manager.get('metadata')
    const created = Date.now()
    const filepath = `/posts/${created}.json`
    const post_data = { title, content, created }
    await drive.put(filepath, Buffer.from(JSON.stringify(post_data)))
    await metadata.append({
      type: 'blog-post',
      data: { filepath, created }
    })
    await audit_log('create_post', { title, filepath })
  }

  // Profile management (app-specific, not in identity)
  async function create_default_profile (username) {
    const profile_drive = ds_manager.get('profile')
    if (await profile_drive.get('/profile.json')) return
    const default_avatar = '<svg><text x="50%" y="50%" font-size="120" text-anchor="middle" dominant-baseline="middle">ðŸ‘¤</text></svg>'
    await profile_drive.put('/avatar.svg', b4a.from(default_avatar))
    await profile_drive.put('/profile.json', b4a.from(JSON.stringify({
      name: username,
      avatar: '/avatar.svg'
    })))
  }

  async function upload_avatar (imageData, filename) {
    const profile_drive = ds_manager.get('profile')
    if (!profile_drive) throw new Error('Profile drive not initialized')
    const ext = filename.split('.').pop().toLowerCase()
    const avatar_path = `/avatar.${ext}`
    await profile_drive.put(avatar_path, b4a.from(imageData))
    // Update profile.json to point to the new avatar
    const profile = await get_profile()
    const updated_profile = { ...profile, avatar: avatar_path }
    await profile_drive.put('/profile.json', b4a.from(JSON.stringify(updated_profile)))
    await audit_log('upload_avatar', { avatar_path })
    emitter.emit('update')
  }

  async function get_profile (profile_key = null) {
    if (typeof profile_key === 'string') return null
    const profile_drive = ds_manager.get('profile')
    if (!profile_drive) return null
    try {
      await profile_drive.ready()
      const profile_data = await profile_drive.get('/profile.json')
      if (!profile_data) return null
      return JSON.parse(b4a.toString(profile_data))
    } catch (err) {
      console.error('Error getting profile:', err)
      return null
    }
  }

  async function get_avatar_content (profile_key = null) {
    const profile_drive = ds_manager.get('profile')
    if (!profile_drive) return null
    try {
      await profile_drive.ready()
      const profile = await get_profile(profile_key)
      if (!profile || !profile.avatar) return null
      const avatar_data = await profile_drive.get(profile.avatar)
      if (!avatar_data) return null
      if (profile.avatar.endsWith('.svg')) return b4a.toString(avatar_data)
      const ext = profile.avatar.split('.').pop().toLowerCase()
      const mimeType = ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : `image/${ext}`
      const base64 = b4a.toString(avatar_data, 'base64')
      return `data:${mimeType};base64,${base64}`
    } catch (err) {
      return null
    }
  }

  // Device/pairing management (delegates to identity with events_drive)
  async function log_event (type, data) {
    const events_drive = ds_manager.get('events')
    return identity.log_event(events_drive, type, data)
  }

  async function get_paired_devices () {
    const events_drive = ds_manager.get('events')
    return identity.get_paired_devices(events_drive)
  }

  async function remove_device (device) {
    const events_drive = ds_manager.get('events')
    await audit_log('remove_device', { device })
    return identity.remove_device(events_drive, device)
  }

  async function get_raw_data (structure_name) {
    return identity.get_raw_data(structure_name)
  }

  // Subscribe to peer
  async function subscribe (key) {
    if (!key || typeof key !== 'string') return false
    const my_key = ds_manager.get_key('metadata')
    if (key === my_key) return false
    try {
      const key_buffer = b4a.from(key, 'hex')
      await setup_peer_autobase(key, key_buffer)
      add_subscribed_peer(key)
      await audit_log('subscribe', { peer_key: key })
      emitter.emit('update')
      return true
    } catch (err) {
      console.error('Subscribe error:', err)
      return false
    }
  }

  // Unsubscribe
  async function unsubscribe (key) {
    remove_subscribed_peer(key)
    const peer_autobase = autobase_cache.get(key)
    if (peer_autobase) {
      await peer_autobase.close()
      autobase_cache.delete(key)
    }
    const peer_drive = drive_cache.get(key)
    if (peer_drive) {
      await peer_drive.close()
      drive_cache.delete(key)
    }
    await audit_log('unsubscribe', { peer_key: key })
    // Keep in discovered_blogs so it shows in "Discovered Peers" again
    emitter.emit('update')
  }

  // Get blog username
  async function get_blog_username () {
    if (!ds_manager) return null
    const metadata = ds_manager.get('metadata')
    if (!metadata || !metadata.view || metadata.view.length === 0) return null
    try {
      const init_raw = await metadata.view.get(0)
      const init_entry = JSON.parse(init_raw)
      return validate_blog_init(init_entry) ? init_entry.data.username : null
    } catch {
      return null
    }
  }

  // Get blog drive keys
  async function get_blog_drive_key (key_name) {
    const metadata = ds_manager.get('metadata')
    if (!metadata || metadata.view.length < 2) return null
    try {
      const extended_raw = await metadata.view.get(1)
      const extended_entry = JSON.parse(extended_raw)
      return extended_entry.data?.[key_name] || null
    } catch {
      return null
    }
  }

  function get_blog_profile_drive_key () { return get_blog_drive_key('profile_drive_key') }
  function get_blog_events_drive_key () { return get_blog_drive_key('events_drive_key') }

  // Get posts
  async function get_posts (key = null) {
    const target_key = key || ds_manager.get_key('metadata')
    const is_my_blog = !key || key === ds_manager.get_key('metadata')
    const metadata = is_my_blog ? ds_manager.get('metadata') : autobase_cache.get(target_key)
    const drive = is_my_blog ? ds_manager.get('drive') : drive_cache.get(target_key)
    if (!metadata || !drive || !metadata.view || !metadata.view.length) return []
    const posts = []
    for (let i = 0; i < metadata.view.length; i++) {
      try {
        const raw = await metadata.view.get(i)
        const entry = JSON.parse(raw)
        if (validate_blog_post(entry)) {
          const post_buffer = await drive.get(entry.data.filepath)
          if (post_buffer) {
            const post = JSON.parse(post_buffer.toString())
            posts.push(post)
          }
        }
      } catch (err) {
        console.error('Error reading post:', err)
      }
    }
    return posts.sort((a, b) => b.created - a.created)
  }

  function get_my_posts () { return get_posts() }

  // Get peer blogs
  async function get_peer_blogs () {
    const blogs = new Map()
    for (const key of get_subscribed_peers()) {
      const blog_data = discovered_blogs.get(key)
      if (blog_data) {
        const posts = await get_posts(key)
        blogs.set(key, { ...blog_data, posts })
      }
    }
    return blogs
  }

  // Getters
  function get_drive () { return ds_manager ? ds_manager.get('drive') : null }
  function get_profile_drive () { return ds_manager ? ds_manager.get('profile') : null }
  function get_autobase_key () { return ds_manager ? ds_manager.get_key('metadata') : null }
  function get_autobase () { return ds_manager ? ds_manager.get('metadata') : null }
  function get_metadata_store () { return ds_manager ? ds_manager.get_store('metadata') : null }
  function get_drive_store () { return ds_manager ? ds_manager.get_store('drive') : null }
  function get_profile_store () { return ds_manager ? ds_manager.get_store('profile') : null }
  function get_events_store () { return ds_manager ? ds_manager.get_store('events') : null }
  function get_discovered_blogs () { return discovered_blogs }
  function get_pairing_result () { return pairing_result }
  function get_local_key () {
    const metadata = ds_manager.get('metadata')
    return metadata ? b4a.toString(metadata.local.key, 'hex') : null
  }
  async function get_app_audit_log_entries () {
    const app_audit = identity.get_app_audit(APP_ID)
    if (!app_audit) return []
    return app_audit.read()
  }
}

/***************************************
GENERAL HELPER FUNCTIONS
***************************************/

/***************************************
MAKE EMITTER
***************************************/
function make_emitter (state = {}) {
  return {
    on: (type, cb) => (state[type] = state[type] || []).push(cb),
    off: (type, cb) => (state[type] = state[type] || [])[state[type].indexOf(cb)] = undefined,
    emit: (type, data) => (state[type] = state[type] || []).map(f => f && f(data))
  }
}

/***************************************
VALIDATE BLOG INIT
***************************************/
function validate_blog_init (entry) {
  const { type, data = {} } = entry || {}
  return type === 'blog-init' &&
         typeof data.username === 'string' &&
         typeof data.title === 'string' &&
         typeof data.drive_key === 'string'
}

/***************************************
VALIDATE BLOG POST
***************************************/
function validate_blog_post (entry) {
  const { type, data = {} } = entry || {}
  return type === 'blog-post' &&
         typeof data.filepath === 'string' &&
         typeof data.created === 'number'
}

/***************************************
LOCAL STORAGE HELPERS
***************************************/
function get_subscribed_peers () {
  try { return JSON.parse(localStorage.getItem('subscribed_peers') || '[]') } catch { return [] }
}

function add_subscribed_peer (key) {
  const peers = get_subscribed_peers()
  if (!peers.includes(key)) {
    peers.push(key)
    localStorage.setItem('subscribed_peers', JSON.stringify(peers))
  }
}

function remove_subscribed_peer (key) {
  localStorage.setItem('subscribed_peers', JSON.stringify(
    get_subscribed_peers().filter(k => k !== key)
  ))
}

/***************************************
GET LOCAL WRITER KEY
***************************************/
function get_local_writer_key (structure, type) {
  if (type === 'autobase') return structure.local?.key
  if (type === 'autodrive' || type === 'auditcore') return structure.base?.local?.key
  return null
}
