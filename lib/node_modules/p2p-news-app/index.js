// P2P News App.. Blog application that receives identity (vault) as parameter
// Exports a single constructor function named blog_app
const b4a = require('b4a')
const blog_content = require('p2p-news-app-content')
const { start_app_networking } = require('p2p-news-app-networking')

// Blog-specific topic for swarm discovery
const BLOG_TOPIC = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

module.exports = blog_app

function blog_app (identity) {
  // identity is the vault object from the identity module

  /***************************************
DATA STRUCTURES, The only place we need to define structures..
***************************************/
  // To add a new structure just add ONE line here:
  // - name: identifier for the structure (e.g., 'comments', 'likes', 'media')
  // - namespace: storage namespace (e.g., 'blog-comments', 'chat-messages')
  // - type: 'autobase' for structured data, 'autodrive' for files (Both are multidevice obviously)
  // - encoding: (autobase only) 'json' or something else
  // - view_name: (autobase only) name for the view hypercore
  //
  // The datastructure-manager handles this automatically:
  // registration, initialization, pairing, replication,  writer management
  const STRUCTURES = [
    { name: 'metadata', namespace: 'blog-feed', type: 'autobase', encoding: 'json', view_name: 'blog-view' },
    { name: 'drive', namespace: 'blog-files', type: 'autodrive' },
    { name: 'profile', namespace: 'blog-profile', type: 'autodrive' },
    { name: 'events', namespace: 'blog-events', type: 'autodrive' }
  // ADD NEW STRUCTURES, Just one line. Example:
  // { name: 'comments', namespace: 'blog-comments', type: 'autodrive' }
  ]

  // Global state
  const state = {
    store: null,
    ds_manager: null,
    pairing_manager: null,
    pairing_result: null,
    discovered_blogs: new Map(),
    peer_relays: new Map(),
    autobase_cache: new Map(),
    drive_cache: new Map(),
    emitter: make_emitter()
  }

  // Create content operations (posts, profiles, subscriptions)
  const content = blog_content(() => state, { audit_log, setup_peer_autobase, identity })

  // Return the blog app API
  const api = {
    init_blog,
    create_invite,
    verify_pairing,
    deny_pairing,
    // Content operations (delegated to blog-content module)
    create_post: content.create_post,
    subscribe: content.subscribe,
    unsubscribe: content.unsubscribe,
    get_blog_username: content.get_blog_username,
    get_blog_profile_drive_key: content.get_blog_profile_drive_key,
    get_blog_events_drive_key: content.get_blog_events_drive_key,
    get_my_posts: content.get_my_posts,
    get_peer_blogs: content.get_peer_blogs,
    get_profile: content.get_profile,
    get_avatar_content: content.get_avatar_content,
    upload_avatar: content.upload_avatar,
    create_default_profile: content.create_default_profile,
    // Device/pairing management
    log_event,
    get_paired_devices,
    remove_device,
    get_raw_data,
    // Relay management
    set_peer_relay,
    // Other getters
    get_local_key,
    get_drive,
    get_profile_drive,
    get_autobase_key,
    get_autobase,
    get_metadata_store,
    get_drive_store,
    get_profile_store,
    get_events_store,
    get_discovered_blogs,
    on_update: (cb) => state.emitter.on('update', cb),
    get_app_audit_log_entries,
    // Expose for internal use
    get_structure_names: () => state.ds_manager.get_names()
  }
  return api

  /***************************************
INTERNAL FUNCTIONS
***************************************/

  // Audit logging helper - uses vault-managed app auditcore
  async function audit_log (op, data = {}) {
    const app_audit = identity.get_app_audit()
    if (app_audit) await app_audit.append({ type: op, data })
  }

  // Store relay URL for a peer (called from protocol exchange)
  function set_peer_relay (key, relay_url) {
    if (relay_url) state.peer_relays.set(key, relay_url)
  }

  // Setup peer autobase
  async function setup_peer_autobase (key, key_buffer) {
    // Check if already exists
    if (state.autobase_cache.has(key)) return state.autobase_cache.get(key)
    // Use datastructure-manager to create peer metadata autobase
    const peer_autobase = await state.ds_manager.create_peer_structure({ name: 'metadata', peer_key: key, peer_key_buffer: key_buffer, store_instance: state.store })
    // Wait for data if empty
    if (peer_autobase.view.length === 0) {
      await new Promise(resolve => peer_autobase.once('update', resolve))
    }
    async function handle_peer_autobase_update () {
      if (peer_autobase.view.length > 0) {
        try {
          const init_raw_data = await peer_autobase.view.get(0)
          const init_entry = JSON.parse(init_raw_data)
          if (validate_blog_init(init_entry)) {
            state.discovered_blogs.set(key, {
              username: init_entry.data.username,
              title: init_entry.data.title,
              drive_key: init_entry.data.drive_key,
              relay_url: state.peer_relays.get(key) || null
            })
            // Setup peer drive
            if (!state.drive_cache.has(key) && init_entry.data.drive_key) {
              const drive_key_buffer = b4a.from(init_entry.data.drive_key, 'hex')
              const peer_drive = await state.ds_manager.create_peer_structure({ name: 'drive', peer_key: key, peer_key_buffer: drive_key_buffer, store_instance: state.store })
              state.drive_cache.set(key, peer_drive)
            }
            state.emitter.emit('update')
          }
        } catch (err) {
          console.error('[setup_peer_autobase] Error processing update:', err)
        }
      }
    }
    peer_autobase.on('update', handle_peer_autobase_update)
    await handle_peer_autobase_update()
    state.autobase_cache.set(key, peer_autobase)
    return peer_autobase
  }

  // Restore subscribed peers
  async function restore_subscribed_peers () {
    if (!state.store) return
    const peers = await content.get_subscribed_peers()
    for (const key of peers) {
      try {
        const key_buffer = b4a.from(key, 'hex')
        await setup_peer_autobase(key, key_buffer)
      } catch (err) {
        console.error('Error restoring peer:', err)
      }
    }
  }

  // VAULT REGISTRATION - Register app structures with vault on init
  async function register_app_with_vault () {
    // Get structure keys for registration
    const structure_keys = {}
    for (const config of STRUCTURES) {
      const key = state.ds_manager.get_key(config.name)
      if (key) {
        structure_keys[config.name] = key
      }
    }
    // Register app with vault (vault auto-creates auditcore and links it)
    await identity.register_app({
      name: 'P2P News App',
      structures: STRUCTURES.map(s => ({
        name: s.name,
        namespace: s.namespace,
        type: s.type,
        key: structure_keys[s.name]
      }))
    })
  }

  /***************************************
   INIT BLOG
  ***************************************/

  async function init_blog ({ username }) {
    state.store = identity.store
    state.ds_manager = identity.create_ds_manager()
    identity.set_ds_manager(state.ds_manager)

    const existing_app = await identity.get_app()
    if (existing_app?.structures) {
      // Returning user — load existing structures
      const keys_map = Object.fromEntries(existing_app.structures.filter(s => s.key).map(s => [s.name, s.key]))
      await state.ds_manager.init_all(STRUCTURES.map(c => ({ ...c, store: state.store })), keys_map)
      if (existing_app.audit_key) await identity.load_app_audit(existing_app.audit_key)
      const metadata = state.ds_manager.get('metadata')
      // edge cases happen in which writer access isnt propogated, in that case get writer access again.
      if (metadata.writable) {
        identity.start_writer_watcher()
      } else {
        await identity.request_writer_access()
        await identity.wait_for_writer_access()
      }
    } else {
      // First-time seed user — create structures
      await state.ds_manager.init_all(STRUCTURES.map(c => ({ ...c, store: state.store })))
      await state.ds_manager.get('metadata').append({
        type: 'blog-init',
        data: { username, title: `${username}'s Blog`, drive_key: state.ds_manager.get_key('drive') }
      })
      await content.create_default_profile(username)
      await register_app_with_vault()
      identity.start_writer_watcher()
    }

    identity.set_events_drive(state.ds_manager.get('events'), state.ds_manager.get_store('events'))
    await identity.log_bootstrap_device()
    const { swarm } = await start_app_networking(state.store, {
      topic: BLOG_TOPIC,
      get_username: () => identity.username || 'unknown',
      get_primary_key: () => state.ds_manager.get_key('metadata')
    })
    await setup_peer_handlers()
    return { store: state.store, swarm }
  }

  // Setup peer discovery handlers
  async function setup_peer_handlers () {
    const metadata = state.ds_manager.get('metadata')
    state.store.on('peer-autobase-key', async ({ key, key_buffer, relay_url }) => {
      if (key === state.ds_manager.get_key('metadata')) return
      if (relay_url) set_peer_relay(key, relay_url)
      if (state.autobase_cache.has(key)) return
      await setup_peer_autobase(key, key_buffer)
    })
    metadata.on('update', () => state.emitter.emit('update'))
    await restore_subscribed_peers()
  }

  // Create invite
  async function create_invite () {
    const { invite_code, invite } = await identity.create_vault_invite()
    const profile = await content.get_profile()
    state.pairing_manager = await identity.setup_vault_pairing({
      invite,
      username: profile?.name || 'Unknown',
      on_verification_needed: (digits) => {
        state.emitter.emit('verification_needed', digits)
        state.emitter.emit('update')
      },
      on_paired: async ({ vault_bee_writer, vault_audit_writer }) => {
        // Vault pairing complete - vault keys are handled by identity module
        // Device entries are created when app structures get writer access, not here
        console.log('[p2p-news-app] Vault paired with new device')
        state.emitter.emit('update')
      }
    })
    return { invite_code, pairing_manager: state.pairing_manager }
  }

  function verify_pairing (code) { return identity.verify_vault_pairing(code) }

  function deny_pairing () {
    identity.deny_vault_pairing()
    state.emitter.emit('update')
  }

  /***************************************
DEVICE MANAGEMENT (delegates to identity)
***************************************/

  async function log_event (type, data) {
    const events_drive = state.ds_manager.get('events')
    return identity.log_event(events_drive, type, data)
  }

  async function get_paired_devices () {
    const events_drive = state.ds_manager.get('events')
    return identity.get_paired_devices(events_drive)
  }

  async function remove_device (device) {
    const events_drive = state.ds_manager.get('events')
    await audit_log('remove_device', { device })
    return identity.remove_device(events_drive, device)
  }

  async function get_raw_data (structure_name) {
    return identity.get_raw_data(structure_name)
  }

  /***************************************
GETTERS
***************************************/

  function get_drive () { return state.ds_manager ? state.ds_manager.get('drive') : null }
  function get_profile_drive () { return state.ds_manager ? state.ds_manager.get('profile') : null }
  function get_autobase_key () { return state.ds_manager ? state.ds_manager.get_key('metadata') : null }
  function get_autobase () { return state.ds_manager ? state.ds_manager.get('metadata') : null }
  function get_metadata_store () { return state.ds_manager ? state.ds_manager.get_store('metadata') : null }
  function get_drive_store () { return state.ds_manager ? state.ds_manager.get_store('drive') : null }
  function get_profile_store () { return state.ds_manager ? state.ds_manager.get_store('profile') : null }
  function get_events_store () { return state.ds_manager ? state.ds_manager.get_store('events') : null }
  function get_discovered_blogs () { return state.discovered_blogs }
  function get_local_key () {
    const metadata = state.ds_manager.get('metadata')
    return metadata ? b4a.toString(metadata.local.key, 'hex') : null
  }
  async function get_app_audit_log_entries () {
    const app_audit = identity.get_app_audit()
    if (!app_audit) return []
    return app_audit.read()
  }
}

/***************************************
GENERAL HELPER FUNCTIONS
***************************************/

/***************************************
MAKE EMITTER
***************************************/
function make_emitter (state = {}) {
  return {
    on: (type, cb) => (state[type] = state[type] || []).push(cb),
    off: (type, cb) => (state[type] = state[type] || [])[state[type].indexOf(cb)] = undefined,
    emit: (type, data) => (state[type] = state[type] || []).map(f => f && f(data))
  }
}

/***************************************
VALIDATE BLOG INIT
***************************************/
function validate_blog_init (entry) {
  const { type, data = {} } = entry || {}
  return type === 'blog-init' &&
         typeof data.username === 'string' &&
         typeof data.title === 'string' &&
         typeof data.drive_key === 'string'
}
