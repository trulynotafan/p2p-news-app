// P2P News App.. Blog application that receives identity (vault) as parameter
// Exports a single constructor function named blog_app
const b4a = require('b4a')

// Blog-specific topic for swarm discovery
const BLOG_TOPIC = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

// App ID for vault registration
const APP_ID = 'p2p-news-app'

module.exports = blog_app

function blog_app (identity) {
  // identity is the vault object from the identity module

// ============================================================================
// DATA STRUCTURES, The only place we need to define structures.. 
// ============================================================================
// To add a new structure just add ONE line here:
// - name: identifier for the structure (e.g., 'comments', 'likes', 'media')
// - namespace: storage namespace (e.g., 'blog-comments', 'chat-messages')
// - type: 'autobase' for structured data, 'autodrive' for files (Both are multidevice obviously)
// - encoding: (autobase only) 'json' or something else
// - view_name: (autobase only) name for the view hypercore
//
// The datastructure-manager handles this automatically:
// registration, initialization, pairing, replication,  writer management
// ============================================================================
const STRUCTURES = [
  { name: 'metadata', namespace: 'blog-metadata', type: 'autobase', encoding: 'json', view_name: 'blog-view' },
  { name: 'drive', namespace: 'blog-files', type: 'autodrive' },
  { name: 'profile', namespace: 'blog-profile', type: 'autodrive' },
  { name: 'events', namespace: 'blog-events', type: 'autodrive' },
  { name: 'app_audit', namespace: 'blog-audit', type: 'auditcore' },
  // ADD NEW STRUCTURES, Just one line. Example:
  // { name: 'comments', namespace: 'blog-comments', type: 'autodrive' }
]
// ============================================================================

// Emitter
const make_emitter = (state = {}) => ({
  on: (type, cb) => (state[type] = state[type] || []).push(cb),
  off: (type, cb) => (state[type] = state[type] || [])[state[type].indexOf(cb)] = undefined,
  emit: (type, data) => (state[type] = state[type] || []).map(f => f && f(data))
})

// Global state
let store, ds_manager, pairing_manager, pairing_result = null
const discovered_blogs = new Map()
const peer_relays = new Map() // Store relay URLs for peers
const autobase_cache = new Map()
const drive_cache = new Map()
const emitter = make_emitter()

// Audit logging helper
const audit_log = async (op, data = {}) => {
  const app_audit = ds_manager?.get('app_audit')
  if (app_audit) await app_audit.append({ type: op, data })
}

// Validation
const validate_blog_init = (entry) => {
  const { type, data = {} } = entry || {}
  return type === 'blog-init' &&
         typeof data.username === 'string' &&
         typeof data.title === 'string' &&
         typeof data.drive_key === 'string'
}

const validate_blog_post = (entry) => {
  const { type, data = {} } = entry || {}
  return type === 'blog-post' &&
         typeof data.filepath === 'string' &&
         typeof data.created === 'number'
}

// LocalStorage helpers
const get_subscribed_peers = () => {
  try { return JSON.parse(localStorage.getItem('subscribed_peers') || '[]') } catch { return [] }
}

const add_subscribed_peer = (key) => {
  const peers = get_subscribed_peers()
  if (!peers.includes(key)) {
    peers.push(key)
    localStorage.setItem('subscribed_peers', JSON.stringify(peers))
  }
}

const remove_subscribed_peer = (key) => {
  localStorage.setItem('subscribed_peers', JSON.stringify(
    get_subscribed_peers().filter(k => k !== key)
  ))
}

// Store relay URL for a peer (called from protocol exchange)
const set_peer_relay = (key, relay_url) => {
  if (relay_url) peer_relays.set(key, relay_url)
}

// Setup peer autobase
const setup_peer_autobase = async (key, key_buffer) => {
  // Check if already exists
  if (autobase_cache.has(key)) return autobase_cache.get(key)
  
  // Use datastructure-manager to create peer metadata autobase
  const peer_autobase = await ds_manager.create_peer_structure('metadata', key, key_buffer, store)

  // Wait for data if empty
  if (peer_autobase.view.length === 0) {
    await new Promise(resolve => peer_autobase.once('update', resolve))
  }

  const handle_peer_autobase_update = async () => {
    if (peer_autobase.view.length > 0) {
      try {
        const init_raw_data = await peer_autobase.view.get(0)
        const init_entry = JSON.parse(init_raw_data)
        
        if (validate_blog_init(init_entry)) {
          discovered_blogs.set(key, {
            username: init_entry.data.username,
            title: init_entry.data.title,
            drive_key: init_entry.data.drive_key,
            relay_url: peer_relays.get(key) || null
          })
          
          // Setup peer drive
          if (!drive_cache.has(key) && init_entry.data.drive_key) {
            const drive_key_buffer = b4a.from(init_entry.data.drive_key, 'hex')
            const peer_drive = await ds_manager.create_peer_structure('drive', key, drive_key_buffer, store)
            drive_cache.set(key, peer_drive)
          }
          
          emitter.emit('update')
        }
      } catch (err) {
        console.error('[setup_peer_autobase] Error processing update:', err)
      }
    }
  }

  peer_autobase.on('update', handle_peer_autobase_update)
  await handle_peer_autobase_update()
  
  autobase_cache.set(key, peer_autobase)
  return peer_autobase
}

// Restore subscribed peers
const restore_subscribed_peers = () => {
  if (!store) return
  
  const handle_peer_key = async (key) => {
    try {
      const key_buffer = b4a.from(key, 'hex')
      await setup_peer_autobase(key, key_buffer)
    } catch (err) {
      console.error('Error restoring peer:', err)
    }
  }
  
  get_subscribed_peers().forEach(handle_peer_key)
}


// VAULT REGISTRATION - Register app structures with vault on init

const register_app_with_vault = async () => {
  const vault_bee = identity.get_vault_bee()

  // Get structure keys for registration
  const structure_keys = {}
  for (const config of STRUCTURES) {
    const key = ds_manager.get_key(config.name)
    if (key) {
      structure_keys[config.name] = key
    }
  }

  // Register app with vault
  await identity.register_app(APP_ID, {
    name: 'P2P News App',
    structures: STRUCTURES.map(s => ({
      name: s.name,
      namespace: s.namespace,
      type: s.type,
      key: structure_keys[s.name]
    })),
    registered_at: Date.now()
  })

  // Link app auditcore to vault's root auditcore
  const vault_audit = identity.get_vault_audit()
  const app_audit_key = structure_keys.app_audit
  if (vault_audit && app_audit_key) {
    await vault_audit.append({ type: 'app_audit_linked', data: { app_id: APP_ID, audit_key: app_audit_key } })
  }
}


// WRITER KEY WATCHER - Watch vault for writer key requests from paired devices

const start_writer_watcher = async () => {
  const vault_bee = identity.get_vault_bee()
  if (!vault_bee) return

  const watcher = vault_bee.watch({ gte: `writer_requests/${APP_ID}`, lt: `writer_requests/${APP_ID}0` })

  ;(async () => {
    for await (const _ of watcher) {
      const requests = await identity.vault_get(`writer_requests/${APP_ID}`)
      if (!requests) continue

      let processed_any = false
      for (const req of requests) {
        if (req.processed) continue
        processed_any = true
        for (const [name, key] of Object.entries(req.writer_keys)) {
          try {
            await ds_manager.add_writer(name, key)
            console.log(`[p2p-news-app] Added writer to ${name}:`, key)
          } catch (err) {
            console.error(`[p2p-news-app] Failed to add writer to ${name}:`, err.message)
          }
        }
        req.processed = true
        req.processed_at = Date.now()

        // Log Device B as a paired device with all its writer keys
        const device_keys = {}
        for (const [name, key] of Object.entries(req.writer_keys)) {
          device_keys[`${name}_writer`] = key
        }
        await log_event('add', device_keys)
      }
      if (processed_any) {
        await identity.vault_put(`writer_requests/${APP_ID}`, requests)
        emitter.emit('update')
      }
    }
  })()
}

// Initialize blog
const init_blog = async (options) => {
  const { username, relay, offline_mode } = options

  // Check if vault already exists (pair mode)
  const vault_bee = identity.get_vault_bee()
  const network_store = identity.get_network_store()
  const swarm_instance = identity.get_swarm()

  if (vault_bee && network_store && swarm_instance) {
    store = network_store
    ds_manager = identity.create_ds_manager()
    identity.set_ds_manager(ds_manager)
    STRUCTURES.forEach(c => ds_manager.register({ ...c, store }))

    const app = await identity.get_app(APP_ID)
    if (!app?.structures) throw new Error('Could not sync with vault. Make sure Device A is online.')

    const keys_map = Object.fromEntries(app.structures.filter(s => s.key).map(s => [s.name, s.key]))
    await ds_manager.init_all_with_keys(keys_map)
    await request_app_writer_access()
    await wait_for_writer_access()

    identity.set_events_drive(ds_manager.get('events'), ds_manager.get_store('events'))
    setup_peer_handlers()
    return { store, swarm: swarm_instance }
  }

  // SEED MODE: Start networking, create vault, then app structures
  const networking_options = {
    name: username,
    store_name: `storage-${username}`,
    topic: BLOG_TOPIC,
    get_primary_key: () => ds_manager ? ds_manager.get_key('metadata') : null,
    get_primary_structure: () => ds_manager ? ds_manager.get('metadata') : null,
    relay,
    offline_mode
  }

  const { store: _store, swarm: _swarm } = await identity.start_networking(networking_options)
  store = _store

  identity.set_swarm(_swarm)

  // Create vault structures in this store
  await identity.init_vault_structures(store, null, null)

  // Save vault keys to localStorage
  const vault_bee_key = identity.get_vault_bee()?.key
  const vault_audit_key = identity.get_vault_audit()?.key
  if (vault_bee_key && vault_audit_key && typeof localStorage !== 'undefined') {
    const b4a = require('b4a')
    localStorage.setItem(`vault_keys_${username}`, JSON.stringify({
      vault_bee: b4a.toString(vault_bee_key, 'hex'),
      vault_audit: b4a.toString(vault_audit_key, 'hex')
    }))
  }

  // Now create app structures
  ds_manager = identity.create_ds_manager()
  identity.set_ds_manager(ds_manager)
  for (const config of STRUCTURES) {
    ds_manager.register({ ...config, store })
  }

  await ds_manager.init_all()
  const metadata = ds_manager.get('metadata')
  await metadata.append({
    type: 'blog-init',
    data: { username, title: `${username}'s Blog`, drive_key: ds_manager.get_key('drive') }
  })

  await create_default_profile(username)
  await log_bootstrap_device()

  // Register app in vault
  await register_app_with_vault()

  const events_drive = ds_manager.get('events')
  identity.set_events_drive(events_drive, ds_manager.get_store('events'))

  start_writer_watcher()
  setup_peer_handlers()

  return { store, swarm: _swarm }
}

// Setup peer discovery handlers
const setup_peer_handlers = () => {
  const metadata = ds_manager.get('metadata')

  store.on('peer-autobase-key', async ({ key, key_buffer, relay_url }) => {
    if (key === ds_manager.get_key('metadata')) return
    if (relay_url) set_peer_relay(key, relay_url)
    if (autobase_cache.has(key)) return
    await setup_peer_autobase(key, key_buffer)
  })

  metadata.on('update', () => emitter.emit('update'))
  restore_subscribed_peers()
}

  // Log bootstrap device with ALL structure writer keys (also dynamic)
const log_bootstrap_device = async () => {
  const device_keys = {}
  for (const name of ds_manager.get_names()) {
    const structure = ds_manager.get(name)
    const config = ds_manager.get_config(name)

    let writer_key = null
    if (config.type === 'autobase') {
      writer_key = structure.local?.key
    } else if (config.type === 'autodrive') {
      writer_key = structure.base?.local?.key
    } else if (config.type === 'auditcore') {
      writer_key = structure.base?.local?.key
    }
    if (writer_key) {
      device_keys[`${name}_writer`] = b4a.toString(writer_key, 'hex')
    }
  }
  const existing_devices = await get_paired_devices()
  const device_exists = existing_devices.some(d => d.metadata_writer === device_keys.metadata_writer)

  if (!device_exists) {
    await log_event('add', device_keys)
  }
}

// Create invite
const create_invite = async () => {
  const { invite_code, invite } = await identity.create_vault_invite(BLOG_TOPIC)
  const profile = await get_profile()

  pairing_manager = await identity.setup_vault_pairing({
    invite,
    username: profile?.name || 'Unknown',
    on_verification_needed: (digits) => emitter.emit('verification_needed', digits),
    on_paired: async ({ vault_bee_writer, vault_audit_writer }) => {
      // Vault pairing complete - vault keys are handled by identity module
      // Device entries are created when app structures get writer access, not here
      console.log('[p2p-news-app] Vault paired with new device')
      emitter.emit('update')
    }
  })
  return { invite_code, pairing_manager }
}

const verify_pairing = (code) => identity.verify_vault_pairing(code)
const deny_pairing = () => { identity.deny_vault_pairing(); emitter.emit('update') }

// Helper to get local writer key from any structure type
const get_local_writer_key = (structure, type) => {
  if (type === 'autobase') return structure.local?.key
  if (type === 'autodrive' || type === 'auditcore') return structure.base?.local?.key
  return null
}

// Request writer access (Device B side)
const request_app_writer_access = async () => {
  if (!identity.get_vault_bee()) return

  const writer_keys = {}
  for (const name of ds_manager.get_names()) {
    const key = get_local_writer_key(ds_manager.get(name), ds_manager.get_config(name).type)
    if (key) writer_keys[name] = b4a.toString(key, 'hex')
  }

  const requests = await identity.vault_get(`writer_requests/${APP_ID}`) || []
  requests.push({ writer_keys, requested_at: Date.now(), processed: false })
  await identity.vault_put(`writer_requests/${APP_ID}`, requests)
  return writer_keys
}

// Wait for Device A to process our writer access request
const wait_for_writer_access = async () => {
  const vault_bee = identity.get_vault_bee()
  const our_key = ds_manager.get('metadata')?.local?.key
  if (!vault_bee || !our_key) return false

  const our_hex = b4a.toString(our_key, 'hex')
  for await (const _ of vault_bee.watch({ gte: `writer_requests/${APP_ID}`, lt: `writer_requests/${APP_ID}0` })) {
    const reqs = await identity.vault_get(`writer_requests/${APP_ID}`)
    if (reqs?.find(r => r.writer_keys?.metadata === our_hex && r.processed)) return true
  }
}

// Create post
const create_post = async (title, content) => {
  const drive = ds_manager.get('drive')
  const metadata = ds_manager.get('metadata')
  
  const created = Date.now()
  const filepath = `/posts/${created}.json`
  const post_data = { title, content, created }
  
  await drive.put(filepath, Buffer.from(JSON.stringify(post_data)))
  await metadata.append({
    type: 'blog-post',
    data: { filepath, created }
  })
  await audit_log('create_post', { title, filepath })
}

// Profile management (app-specific, not in identity)
const create_default_profile = async (username) => {
  const profile_drive = ds_manager.get('profile')
  
  // use the profile pic if it exists
  if (await profile_drive.get('/profile.json')) return
  
  const default_avatar = `<svg><text x="50%" y="50%" font-size="120" text-anchor="middle" dominant-baseline="middle">ğŸ‘¤</text></svg>`
  
  await profile_drive.put('/avatar.svg', b4a.from(default_avatar))
  await profile_drive.put('/profile.json', b4a.from(JSON.stringify({
    name: username,
    avatar: '/avatar.svg'
  })))
}

const upload_avatar = async (imageData, filename) => {
  const profile_drive = ds_manager.get('profile')
  if (!profile_drive) {
    throw new Error('Profile drive not initialized')
  }
  
  // Get file extension from filename
  const ext = filename.split('.').pop().toLowerCase()
  const avatar_path = `/avatar.${ext}`
  
  // Store the image file
  await profile_drive.put(avatar_path, b4a.from(imageData))
  
  // Update profile.json to point to the new avatar
 const profile = await get_profile()
  const updated_profile = {
    ...profile,
    avatar: avatar_path
  }
  
  await profile_drive.put('/profile.json', b4a.from(JSON.stringify(updated_profile)))
  await audit_log('upload_avatar', { avatar_path })
  emitter.emit('update')
}

const get_profile = async (profile_key = null) => {
  // If string key passed, ignore it
  if (typeof profile_key === 'string') return null
  
  const profile_drive = ds_manager.get('profile')
  if (!profile_drive) return null
  
  try {
    await profile_drive.ready()  
    const profile_data = await profile_drive.get('/profile.json')
    if (!profile_data) return null
    return JSON.parse(b4a.toString(profile_data))
  } catch (err) {
    console.error('Error getting profile:', err)
    return null
  }
}

const get_avatar_content = async (profile_key = null) => {
  const profile_drive = ds_manager.get('profile')
  if (!profile_drive) return null
  
  try {
    await profile_drive.ready()
    
    // Get profile to find avatar path
    const profile = await get_profile(profile_key)
    if (!profile || !profile.avatar) return null
    
    const avatar_data = await profile_drive.get(profile.avatar)
    if (!avatar_data) return null
    
    // For SVG files, return as text
    if (profile.avatar.endsWith('.svg')) {
      return b4a.toString(avatar_data)
    }
    
    // For image files, return as data URL
    const ext = profile.avatar.split('.').pop().toLowerCase()
    const mimeType = ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : `image/${ext}`
    const base64 = b4a.toString(avatar_data, 'base64')
    return `data:${mimeType};base64,${base64}`
  } catch (err) {
    return null
  }
}

// Device/pairing management (delegates to identity with events_drive)
const log_event = async (type, data) => {
  const events_drive = ds_manager.get('events')
  return identity.log_event(events_drive, type, data)
}

const get_paired_devices = async () => {
  const events_drive = ds_manager.get('events')
  return identity.get_paired_devices(events_drive)
}

const remove_device = async (device) => {
  const events_drive = ds_manager.get('events')
  await audit_log('remove_device', { device })
  return identity.remove_device(events_drive, device)
}

const get_raw_data = async (structure_name) => {
  return identity.get_raw_data(structure_name)
}

// Subscribe to peer
const subscribe = async (key) => {
  if (!key || typeof key !== 'string') return false
  
  const my_key = ds_manager.get_key('metadata')
  if (key === my_key) return false
  
  try {
    const key_buffer = b4a.from(key, 'hex')
    await setup_peer_autobase(key, key_buffer)
    add_subscribed_peer(key)
    await audit_log('subscribe', { peer_key: key })
    emitter.emit('update')
    return true
  } catch (err) {
    console.error('Subscribe error:', err)
    return false
  }
}

// Unsubscribe
const unsubscribe = async (key) => {
  remove_subscribed_peer(key)
  
  const peer_autobase = autobase_cache.get(key)
  if (peer_autobase) {
    await peer_autobase.close()
    autobase_cache.delete(key)
  }
  
  const peer_drive = drive_cache.get(key)
  if (peer_drive) {
    await peer_drive.close()
    drive_cache.delete(key)
  }
  
  await audit_log('unsubscribe', { peer_key: key })
  // Keep in discovered_blogs so it shows in "Discovered Peers" again
  emitter.emit('update')
}

// Get blog username
const get_blog_username = async () => {
  if (!ds_manager) return null
  const metadata = ds_manager.get('metadata')
  if (!metadata || !metadata.view || metadata.view.length === 0) return null
  
  try {
    const init_raw = await metadata.view.get(0)
    const init_entry = JSON.parse(init_raw)
    return validate_blog_init(init_entry) ? init_entry.data.username : null
  } catch {
    return null
  }
}

// Get blog drive keys
const get_blog_drive_key = async (key_name) => {
  const metadata = ds_manager.get('metadata')
  if (!metadata || metadata.view.length < 2) return null
  
  try {
    const extended_raw = await metadata.view.get(1)
    const extended_entry = JSON.parse(extended_raw)
    return extended_entry.data?.[key_name] || null
  } catch {
    return null
  }
}

const get_blog_profile_drive_key = () => get_blog_drive_key('profile_drive_key')
const get_blog_events_drive_key = () => get_blog_drive_key('events_drive_key')

// Get posts
const get_posts = async (key = null) => {
  const target_key = key || ds_manager.get_key('metadata')
  const is_my_blog = !key || key === ds_manager.get_key('metadata')
  
  const metadata = is_my_blog ? ds_manager.get('metadata') : autobase_cache.get(target_key)
  const drive = is_my_blog ? ds_manager.get('drive') : drive_cache.get(target_key)
  
  if (!metadata || !drive) return []
  if (!metadata.view || !metadata.view.length) return []
  
  const posts = []
  
  for (let i = 0; i < metadata.view.length; i++) {
    try {
      const raw = await metadata.view.get(i)
      const entry = JSON.parse(raw)
      
      if (validate_blog_post(entry)) {
        const post_buffer = await drive.get(entry.data.filepath)
        if (post_buffer) {
          const post = JSON.parse(post_buffer.toString())
          posts.push(post)
        }
      }
    } catch (err) {
      console.error('Error reading post:', err)
    }
  }
  
  return posts.sort((a, b) => b.created - a.created)
}

const get_my_posts = () => get_posts()

// Get peer blogs
const get_peer_blogs = async () => {
  const blogs = new Map()
  
  for (const key of get_subscribed_peers()) {
    const blog_data = discovered_blogs.get(key)
    if (blog_data) {
      const posts = await get_posts(key)
      blogs.set(key, { ...blog_data, posts })
    }
  }
  
  return blogs
}

// Getters
const get_drive = () => ds_manager ? ds_manager.get('drive') : null
const get_profile_drive = () => ds_manager ? ds_manager.get('profile') : null
const get_autobase_key = () => ds_manager ? ds_manager.get_key('metadata') : null
const get_autobase = () => ds_manager ? ds_manager.get('metadata') : null
const get_metadata_store = () => ds_manager ? ds_manager.get_store('metadata') : null
const get_drive_store = () => ds_manager ? ds_manager.get_store('drive') : null
const get_profile_store = () => ds_manager ? ds_manager.get_store('profile') : null
const get_events_store = () => ds_manager ? ds_manager.get_store('events') : null
const get_local_key = () => {
  const metadata = ds_manager.get('metadata')
  return metadata ? b4a.toString(metadata.local.key, 'hex') : null
}
const get_discovered_blogs = () => discovered_blogs
const get_pairing_result = () => pairing_result
const get_structure_names = () => ds_manager ? ds_manager.get_names() : []

  // Return the blog app API
  const api = {
    init_blog,
    create_post,
    create_invite,
    verify_pairing,
    deny_pairing,
    subscribe,
    unsubscribe,
    get_blog_username,
    get_blog_profile_drive_key,
    get_blog_events_drive_key,
    get_my_posts,
    get_peer_blogs,
    // Profile management
    get_profile,
    get_avatar_content,
    upload_avatar,
    create_default_profile,
    // Device/pairing management
    log_event,
    get_paired_devices,
    remove_device,
    get_raw_data,
    // Relay management
    set_peer_relay,
    // Other getters
    get_local_key,
    get_drive,
    get_profile_drive,
    get_autobase_key,
    get_autobase,
    get_metadata_store,
    get_drive_store,
    get_profile_store,
    get_events_store,
    get_discovered_blogs,

    get_structure_names,
    on_update: (cb) => emitter.on('update', cb)
  }

  return api
}