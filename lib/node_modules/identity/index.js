// Identity module which is app independent
// This module handles: keypairs, pairing, networking, data structures
// Doesnt contain app-specific things
// Exports a single constructor function that returns {make, load} API

const b4a = require('b4a')
const Corestore = require('corestore')
const BlindPairing = require('blind-pairing')
const pairing_manager_constructor = require('pairing-manager')
const datastructure_manager = require('datastructure-manager')
const { create_autobee } = require('autobee')
const { create_auditcore } = require('auditcore')
const { start_networking } = require('identity-networking')
const { create_vault_ops, make_emitter, parse_vault_invite } = require('identity-operations')

const is_cli = typeof globalThis.open === 'undefined'
const RAW = is_cli ? null : require('random-access-web')

module.exports = identity

function identity (config = {}) {
  const {
    name = 'browser-peer'
  } = config

  // Create corestore for this identity
  const store = is_cli
    ? new Corestore(`./storage-identity-${name}`)
    : new Corestore(RAW(`identity-${name}`))

  // Global state for this identity instance
  const state = {
    events_drive: null,
    events_store: null,
    ds_manager: null,
    pairing_manager: null,
    swarm: null,
    dht: null,
    keypair: null,
    vault_bee: null, // Key-value store for vault data
    vault_audit: null, // Audit log for all vault operations
    network_store: null, // Store reference for vault operations
    pending_auth: null, // Pending authentication data (for pair mode)
    app_audits: new Map(), // app_id -> auditcore instance
    emitter: make_emitter()
  }

  // Store config for later use
  const vault_config = config

  // User auth promise, resolves when authentication completes
  let user_resolve, user_reject
  const user = new Promise((resolve, reject) => {
    user_resolve = resolve
    user_reject = reject
  })

  // Create vault operations (vault API, events, devices, raw data)
  const vault = create_vault_ops(() => state)

  // Return vault object with all identity functions (app-independent only)
  const vault_api = {
    // Config for apps to access
    config: vault_config,
    // User promise (replaces login)
    user,
    authenticate,
    // Networking setup
    start_networking,
    // Vault-only pairing
    create_vault_invite,
    setup_vault_pairing,
    verify_vault_pairing,
    deny_vault_pairing,
    // Data structure management
    create_ds_manager,
    // Vault structure initialization (for apps to create vault in seed mode)
    init_vault_structures,
    // Vault operations (delegated to vault-ops module)
    log_event: vault.log_event,
    get_events: vault.get_events,
    get_paired_devices: vault.get_paired_devices,
    get_device_name: vault.get_device_name,
    remove_device: vault.remove_device,
    get_raw_data: vault.get_raw_data,
    register_app: vault.register_app,
    load_app_audit: vault.load_app_audit,
    get_app: vault.get_app,
    list_apps: vault.list_apps,
    vault_put: vault.vault_put,
    vault_get: vault.vault_get,
    vault_del: vault.vault_del,
    // Complete authentication (called by websys-ui after app join flow)
    complete_authentication,
    // Setters
    set_events_drive,
    set_ds_manager,
    set_pairing_manager,
    set_swarm,
    set_dht,
    set_keypair,
    // Getters
    get_events_drive,
    get_events_store,
    get_store,
    get_swarm,
    get_dht,
    get_keypair,
    get_ds_manager,
    get_vault_bee,
    get_vault_audit,
    get_network_store,
    get_app_audit,
    // Events
    on_update: handle_update_callback,
    on_vault_ready,
    // Session management
    session_set,
    session_get,
    session_clear,
    reset_all_data
  }
  return vault_api

  /***************************************
INTERNAL FUNCTIONS
***************************************/

  // Authenticate is called by the App's UI. It autheticates the user based on the mode.
  // If user is new, it resolves quickly. If not, it sets up networking to handle pairing.
  async function authenticate (auth_data) {
    const { username, mode, invite_code, on_verification_code } = auth_data
    try {
      if (mode === 'pair' && invite_code) {
        const invite_data = parse_vault_invite(invite_code)
        const topic = invite_data.topic ? b4a.from(invite_data.topic, 'hex') : null
        if (!topic) {
          if (user_reject) user_reject(new Error('Invite missing topic'))
          return
        }
        const networking_options = {
          name: username,
          store_name: `storage-${username}`,
          topic,
          relay: vault_config.relay
        }
        const { store: _network_store, swarm: swarm_instance } = await start_networking(networking_options)
        state.network_store = _network_store
        state.swarm = swarm_instance
        state.pairing_manager = pairing_manager_constructor(state.swarm)
        // Create vault structures FIRST using keys from invite
        // Pairing device will now only create structures once.
        await init_vault_structures({ store: state.network_store, vault_bee_key: invite_data.vault_bee_key, vault_audit_key: invite_data.vault_audit_key })
        // Now join pairing with the created structures
        const result = await state.pairing_manager.join_with_invite({
          invite_code,
          vault_bee: state.vault_bee,
          vault_audit: state.vault_audit,
          on_verification_code_ready: (code) => {
            if (on_verification_code) on_verification_code(code)
          }
        })
        state.pending_auth = {
          username: result.username || username,
          mode,
          store: state.network_store,
          swarm: state.swarm
        }
        state.emitter.emit('vault_ready', state.pending_auth)
        return
      }
      // Seed mode: resolve immediately, app will handle networking
      const authenticated_vault = {
        ...vault_api,
        username,
        mode,
        authenticated: true
      }
      if (user_resolve) user_resolve(authenticated_vault)
    } catch (err) {
      console.error('[identity] Authentication error:', err)
      if (user_reject) user_reject(err)
    }
  }

  function complete_authentication () {
    if (!state.pending_auth) return
    const authenticated_vault = {
      ...vault_api,
      username: state.pending_auth.username,
      mode: state.pending_auth.mode,
      authenticated: true,
      store: state.pending_auth.store,
      swarm: state.pending_auth.swarm
    }
    if (user_resolve) user_resolve(authenticated_vault)
    state.pending_auth = null
  }

  /***************************************
VAULT STRUCTURE INITIALIZATION
***************************************/

  async function init_vault_structures (options) {
    const { store, vault_bee_key, vault_audit_key } = options
    state.network_store = store
    state.vault_bee = create_autobee({
      store: store.namespace('vault-bee'),
      bootstrap: vault_bee_key ? b4a.from(vault_bee_key, 'hex') : null
    })
    state.vault_audit = create_auditcore({
      store: store.namespace('vault-audit'),
      bootstrap: vault_audit_key ? b4a.from(vault_audit_key, 'hex') : null
    })
    await state.vault_bee.ready()
    await state.vault_audit.ready()
  }

  /***************************************
VAULT PAIRING
***************************************/

  async function create_vault_invite (topic = null) {
    if (!state.vault_bee || !state.vault_audit) throw new Error('Vault not initialized')
    const vault_bee_key = b4a.toString(state.vault_bee.key, 'hex')
    const vault_audit_key = b4a.toString(state.vault_audit.key, 'hex')
    const invite_obj = BlindPairing.createInvite(state.vault_bee.key)
    const topic_hex = topic ? b4a.toString(topic, 'hex') : null
    const invite_data = { vault_bee_key, vault_audit_key, blind_invite: b4a.toString(invite_obj.invite, 'base64'), vault_only: true, topic: topic_hex }
    await state.vault_audit.append({ type: 'invite_created', data: { topic: topic_hex } })
    return {
      invite_code: b4a.toString(b4a.from(JSON.stringify(invite_data)), 'base64'),
      invite: invite_obj,
      vault_bee_key,
      vault_audit_key
    }
  }

  async function setup_vault_pairing (config) {
    if (!state.vault_bee || !state.vault_audit || !state.swarm) throw new Error('Vault not initialized')
    state.pairing_manager = pairing_manager_constructor(state.swarm)
    await state.pairing_manager.setup_member({ ...config, vault_bee: state.vault_bee, vault_audit: state.vault_audit })
    return state.pairing_manager
  }

  async function verify_vault_pairing (entered_code) {
    if (!state.pairing_manager) throw new Error('Pairing not setup')
    return state.pairing_manager.verify_and_complete_pairing({ entered_verification_code: entered_code, vault_bee: state.vault_bee, vault_audit: state.vault_audit })
  }

  function deny_vault_pairing () {
    if (!state.pairing_manager) throw new Error('Pairing not setup')
    state.pairing_manager.deny_pairing()
  }

  /***************************************
SETTERS
***************************************/

  function set_events_drive (drive, store_instance, setup_callback) {
    state.events_drive = drive
    state.events_store = store_instance
    setup_callback?.()
    state.emitter.emit('update')
  }

  function create_ds_manager () { return datastructure_manager() }
  function set_ds_manager (manager) { state.ds_manager = manager }
  function set_pairing_manager (manager) { state.pairing_manager = manager }
  function set_swarm (swarm_instance) { state.swarm = swarm_instance }
  function set_dht (dht_instance) { state.dht = dht_instance }
  function set_keypair (keypair_instance) { state.keypair = keypair_instance }

  /***************************************
GETTERS
***************************************/

  function get_events_drive () { return state.events_drive }
  function get_events_store () { return state.events_store }
  function get_store () { return store }
  function get_swarm () { return state.swarm }
  function get_dht () { return state.dht }
  function get_keypair () { return state.keypair }
  function get_ds_manager () { return state.ds_manager }
  function get_vault_bee () { return state.vault_bee }
  function get_vault_audit () { return state.vault_audit }
  function get_network_store () { return state.network_store }
  function get_app_audit (app_id) { return state.app_audits.get(app_id) || null }

  /***************************************
EVENT EMITTER
***************************************/

  function handle_update_callback (cb) { return state.emitter.on('update', cb) }
  function on_vault_ready (cb) { return state.emitter.on('vault_ready', cb) }

  /***************************************
  SESSION MANAGEMENT - only vault accesses localStorage direcly
  ***************************************/
  function session_set (key, value) { localStorage.setItem(key, value) }
  function session_get (key) { return localStorage.getItem(key) }
  function session_clear () { localStorage.clear() }
  async function reset_all_data () {
    localStorage.clear()
    if (is_cli) return reset_cli_data()
    return reset_browser_data()
  }

  /* We already have a localstorage shim for CLi environment,
  as cli also uses the same vault apis, in its environment, it will use helpers/local-storage-shim.
  so we don't have to do much here on the vault code. */
  function reset_cli_data () {
    localStorage.reset_all()
  }

  /***************************************
  Reset Browser IndexedDB
  ***************************************/

  async function reset_browser_data () {
    const databases = await indexedDB.databases()
    for (const db of databases) {
      if (db.name && (db.name.includes('blogs-') || db.name.includes('random-access-web') || db.name.includes('identity-'))) {
        indexedDB.deleteDatabase(db.name)
      }
    }
    if (typeof requestFileSystem === 'undefined' && typeof webkitRequestFileSystem === 'undefined') return
    const rfs = typeof requestFileSystem !== 'undefined' ? requestFileSystem : webkitRequestFileSystem
    const persistent = typeof self !== 'undefined' ? self.PERSISTENT : 1
    await new Promise(init_cleanup)
    function init_cleanup (resolve, reject) {
      rfs(persistent, 1024 * 1024, (fs) => read_root(fs, resolve, reject), reject)
    }
    function read_root (fs, resolve, reject) {
      fs.root.createReader().readEntries((entries) => process_entries(entries, resolve), reject)
    }
    function process_entries (entries, resolve) {
      if (!entries.length) return resolve()
      let completed = 0
      const total = entries.length
      function on_done () {
        if (++completed === total) resolve()
      }
      entries.forEach(remove_entry)
      function remove_entry (entry) {
        if (entry.isFile) entry.remove(on_done, on_done)
        else entry.removeRecursively(on_done, on_done)
      }
    }
  }
}
