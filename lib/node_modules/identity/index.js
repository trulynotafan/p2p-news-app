// Identity module which is app independent
// This module handles: keypairs, pairing, networking, data structures
// Doesnt contain app-specific things
// Exports a single constructor function that returns {make, load} API

const b4a = require('b4a')
const Corestore = require('corestore')
const pairing_manager_constructor = require('pairing-manager')
const datastructure_manager = require('datastructure-manager')
const { create_autobee } = require('autobee')
const { create_auditcore } = require('auditcore')
const { network } = require('identity-networking')
const { create_vault_ops, make_emitter, parse_vault_invite } = require('identity-operations')
const { get_or_create_keypair } = require('crypto-helpers')

const is_cli = typeof globalThis.open === 'undefined'
const RAW = is_cli ? null : require('random-access-web')

module.exports = identity

function identity (config = {}) {
  const {
    name = 'browser-peer'
  } = config

  // Create corestore for this identity
  const store = is_cli
    ? new Corestore(`./storage-identity-${name}`)
    : new Corestore(RAW(`identity-${name}`))

  // Global state for this identity instance
  const state = {
    events_drive: null,
    events_store: null,
    ds_manager: null,
    pairing_manager: null,
    swarm: null,
    dht: null,
    keypair: null,
    vault_bee: null, // Key-value store for vault data
    vault_audit: null, // Audit log for all vault operations
    store: null, // Store reference for vault operations
    pending_auth: null, // Pending authentication data (for pair mode)
    app_audits: new Map(), // app_id -> auditcore instance
    emitter: make_emitter()
  }

  // Store config for later use
  const vault_config = config

  // User auth promise, resolves when authentication completes
  let user_resolve, user_reject
  const user = new Promise((resolve, reject) => {
    user_resolve = resolve
    user_reject = reject
  })

  // Create Noise Keypair (Centrally managed via crypto-helpers)
  const user_promise = get_or_create_keypair('vault')

  // Create vault operations (vault API, events, devices, raw data)
  const vault = create_vault_ops(() => state)

  // Return vault object with all identity functions (app-independent only)
  const vault_api = {
    // Config for apps to access
    config: vault_config,
    // User promise (replaces login)
    user,
    authenticate,
    // Vault-only pairing
    create_vault_invite,
    setup_vault_pairing,
    verify_vault_pairing,
    deny_vault_pairing,
    // Data structure management
    create_ds_manager,
    // Vault structure initialization (for apps to create vault in seed mode)
    init_vault_structures,
    // Vault operations (delegated to vault-ops module)
    log_event: vault.log_event,
    get_events: vault.get_events,
    get_paired_devices: vault.get_paired_devices,
    get_device_name: vault.get_device_name,
    remove_device: vault.remove_device,
    get_raw_data: vault.get_raw_data,
    register_app: vault.register_app,
    load_app_audit: vault.load_app_audit,
    get_app: vault.get_app,
    list_apps: vault.list_apps,
    vault_put: vault.vault_put,
    vault_get: vault.vault_get,
    vault_del: vault.vault_del,
    // Writer access management
    start_writer_watcher: vault.start_writer_watcher,
    request_writer_access: vault.request_writer_access,
    wait_for_writer_access: vault.wait_for_writer_access,
    log_bootstrap_device: vault.log_bootstrap_device,
    // Complete authentication (called by websys-ui after app join flow)
    complete_authentication,
    // Setters
    set_events_drive,
    set_ds_manager,
    set_pairing_manager,
    set_swarm,
    set_dht,
    get_events_drive,
    get_events_store,
    store,
    get_swarm,
    get_dht,
    get_ds_manager,
    get_vault_bee,
    get_vault_audit,
    get_app_audit,
    // Events
    on_update: handle_update_callback,
    on_vault_ready,
    // Session management
    session_set,
    session_get,
    session_clear,
    reset_all_data
  }
  return vault_api

  /***************************************
INTERNAL FUNCTIONS
***************************************/

  // Authenticate is called by the App's UI. It autheticates the user based on the mode.
  // If user is new, it resolves quickly. If not, it sets up networking to handle pairing.
  async function authenticate (auth_data) {
    const { username, mode, invite_code, on_verification_code } = auth_data
    try {
      if (mode === 'pair' && invite_code) {
        const invite_data = parse_vault_invite(invite_code)
        const mnemonic_data = await user_promise
        state.keypair = mnemonic_data
        const { swarm: swarm_instance } = await network(store, mnemonic_data)
        state.store = store
        state.swarm = swarm_instance
        state.pairing_manager = pairing_manager_constructor(state.swarm)
        await init_vault_structures({ store, vault_bee_key: invite_data.vault_bee_key, vault_audit_key: invite_data.vault_audit_key })
        const result = await state.pairing_manager.join_with_invite({
          invite_code,
          vault_bee: state.vault_bee,
          vault_audit: state.vault_audit,
          on_verification_code_ready: (code) => {
            if (on_verification_code) on_verification_code(code)
          }
        })
        state.pending_auth = {
          username: result.username || username,
          mode
        }
        state.emitter.emit('vault_ready', state.pending_auth)
        return
      }
      // Seed mode
      const mnemonic_data = await user_promise
      state.keypair = mnemonic_data
      await init_vault_structures({ store, vault_bee_key: null, vault_audit_key: null })
      await store_device_noise_key(mnemonic_data.keypair.publicKey.toString('hex'))
      const { swarm } = await network(store, mnemonic_data)
      // Reconnect to known devices + store new device keys
      const known = await get_other_device_keys(mnemonic_data.keypair.publicKey)
      for (const key of known) swarm.joinPeer(key)
      swarm.on('connection', (socket) => store_device_noise_key(b4a.toString(socket.remotePublicKey, 'hex')))
      state.store = store
      state.swarm = swarm
      if (user_resolve) user_resolve({ ...vault_api, username, mode, authenticated: true })
    } catch (err) {
      console.error('[identity] Authentication error:', err)
      if (user_reject) user_reject(err)
    }
  }

  function complete_authentication () {
    if (!state.pending_auth) return
    const authenticated_vault = {
      ...vault_api,
      username: state.pending_auth.username,
      mode: state.pending_auth.mode,
      authenticated: true
    }
    if (user_resolve) user_resolve(authenticated_vault)
    state.pending_auth = null
  }

  /***************************************
VAULT STRUCTURE INITIALIZATION
***************************************/

  async function init_vault_structures (options) {
    if (state.vault_bee) return // already initialized
    const { store: _store, vault_bee_key, vault_audit_key } = options
    state.store = _store
    state.vault_bee = create_autobee({
      store: _store.namespace('vault-bee'),
      bootstrap: vault_bee_key ? b4a.from(vault_bee_key, 'hex') : null
    })
    state.vault_audit = create_auditcore({
      store: _store.namespace('vault-audit'),
      bootstrap: vault_audit_key ? b4a.from(vault_audit_key, 'hex') : null
    })
    await state.vault_bee.ready()
    await state.vault_audit.ready()
  }

  /***************************************
DEVICE NOISE KEY MANAGEMENT
***************************************/

  async function get_other_device_keys (own_pubkey) {
    const keys = []
    for await (const entry of state.vault_bee.create_read_stream({ gte: 'devices/noise/', lt: 'devices/noise0' })) {
      const key = b4a.from(entry.key.replace('devices/noise/', ''), 'hex')
      if (!b4a.equals(key, own_pubkey)) keys.push(key)
    }
    return keys
  }

  async function store_device_noise_key (noise_key_hex) {
    const existing = await state.vault_bee.get(`devices/noise/${noise_key_hex}`)
    if (existing) return
    await state.vault_bee.put(`devices/noise/${noise_key_hex}`, { added: Date.now() })
  }

  /***************************************
VAULT PAIRING
***************************************/

  function get_pairing_manager () {
    if (!state.pairing_manager) state.pairing_manager = pairing_manager_constructor(state.swarm)
    return state.pairing_manager
  }

  async function create_vault_invite () {
    if (!state.vault_bee || !state.vault_audit) throw new Error('Vault not initialized')
    const vault_bee_key = b4a.toString(state.vault_bee.key, 'hex')
    const vault_audit_key = b4a.toString(state.vault_audit.key, 'hex')
    const invite_obj = get_pairing_manager().create_invite(state.vault_bee.key)
    const invite_data = { vault_bee_key, vault_audit_key, blind_invite: b4a.toString(invite_obj.invite, 'base64'), vault_only: true }
    await state.vault_audit.append({ type: 'invite_created', data: {} })
    return {
      invite_code: b4a.toString(b4a.from(JSON.stringify(invite_data)), 'base64'),
      invite: invite_obj,
      vault_bee_key,
      vault_audit_key
    }
  }

  async function setup_vault_pairing (config) {
    const pm = get_pairing_manager()
    await pm.setup_member({ ...config, vault_bee: state.vault_bee, vault_audit: state.vault_audit })
    return pm
  }

  async function verify_vault_pairing (entered_code) {
    if (!state.pairing_manager) throw new Error('Pairing not setup')
    return state.pairing_manager.verify_and_complete_pairing({ entered_verification_code: entered_code, vault_bee: state.vault_bee, vault_audit: state.vault_audit })
  }

  function deny_vault_pairing () {
    if (!state.pairing_manager) throw new Error('Pairing not setup')
    state.pairing_manager.deny_pairing()
  }

  /***************************************
SETTERS
***************************************/

  function set_events_drive (drive, store_instance, setup_callback) {
    state.events_drive = drive
    state.events_store = store_instance
    setup_callback?.()
    state.emitter.emit('update')
  }

  function create_ds_manager () { return datastructure_manager() }
  function set_ds_manager (manager) { state.ds_manager = manager }
  function set_pairing_manager (manager) { state.pairing_manager = manager }
  function set_swarm (swarm_instance) { state.swarm = swarm_instance }
  function set_dht (dht_instance) { state.dht = dht_instance }

  /***************************************
GETTERS
***************************************/

  function get_events_drive () { return state.events_drive }
  function get_events_store () { return state.events_store }
  function get_swarm () { return state.swarm }
  function get_dht () { return state.dht }
  function get_ds_manager () { return state.ds_manager }
  function get_vault_bee () { return state.vault_bee }
  function get_vault_audit () { return state.vault_audit }
  function get_app_audit (app_id) { return state.app_audits.get(app_id) || null }

  /***************************************
EVENT EMITTER
***************************************/

  function handle_update_callback (cb) { return state.emitter.on('update', cb) }
  function on_vault_ready (cb) { return state.emitter.on('vault_ready', cb) }

  /***************************************
  SESSION MANAGEMENT - only vault accesses localStorage direcly
  ***************************************/
  function session_set (key, value) { localStorage.setItem(key, value) }
  function session_get (key) { return localStorage.getItem(key) }
  function session_clear () { localStorage.clear() }
  async function reset_all_data () {
    localStorage.clear()
    if (is_cli) return reset_cli_data()
    return reset_browser_data()
  }

  /* We already have a localstorage shim for CLi environment,
  as cli also uses the same vault apis, in its environment, it will use helpers/local-storage-shim.
  so we don't have to do much here on the vault code. */
  function reset_cli_data () {
    localStorage.reset_all()
  }

  /***************************************
  Reset Browser IndexedDB
  ***************************************/

  async function reset_browser_data () {
    const databases = await indexedDB.databases()
    for (const db of databases) {
      if (db.name && (db.name.includes('blogs-') || db.name.includes('random-access-web') || db.name.includes('identity-'))) {
        indexedDB.deleteDatabase(db.name)
      }
    }
    if (typeof requestFileSystem === 'undefined' && typeof webkitRequestFileSystem === 'undefined') return
    const rfs = typeof requestFileSystem !== 'undefined' ? requestFileSystem : webkitRequestFileSystem
    const persistent = typeof self !== 'undefined' ? self.PERSISTENT : 1
    await new Promise(init_cleanup)
    function init_cleanup (resolve, reject) {
      rfs(persistent, 1024 * 1024, (fs) => read_root(fs, resolve, reject), reject)
    }
    function read_root (fs, resolve, reject) {
      fs.root.createReader().readEntries((entries) => process_entries(entries, resolve), reject)
    }
    function process_entries (entries, resolve) {
      if (!entries.length) return resolve()
      let completed = 0
      const total = entries.length
      function on_done () {
        if (++completed === total) resolve()
      }
      entries.forEach(remove_entry)
      function remove_entry (entry) {
        if (entry.isFile) entry.remove(on_done, on_done)
        else entry.removeRecursively(on_done, on_done)
      }
    }
  }
}
