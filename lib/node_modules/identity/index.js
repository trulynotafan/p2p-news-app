// Identity module which is app independent
// This module handles: keypairs, pairing, networking, data structures
// Doesnt contain app-specific things
// Exports a single constructor function that returns {make, load} API

const b4a = require('b4a')
const Corestore = require('corestore')

// Environment-based storage
// because we have to deal with bot the cli & web peers
const is_cli = typeof globalThis.open === 'undefined'

const Hyperswarm = require('hyperswarm')
const Protomux = require('protomux')
const BlindPairing = require('blind-pairing')
const pairing_manager_constructor = require('pairing-manager')
const datastructure_manager = require('datastructure-manager')
const { create_mnemonic_keypair, save, load: load_mnemonic } = require('crypto-helpers')
const { identity_exchange_protocol, create_cli_protocol_handlers, create_browser_protocol_handlers } = require('protocol-helpers')
const { create_autobee } = require('autobee')
const { create_auditcore } = require('auditcore')

// Browser-only modules (would break in CLI environment)
const RAW = is_cli ? null : require('random-access-web')
const DHT = require('@hyperswarm/dht-relay')
const Stream = require('@hyperswarm/dht-relay/ws')
const HyperWebRTC = is_cli ? null : require('hyper-webrtc')

module.exports = identity

function identity (config = {}) {
  const {
    name = 'browser-peer'
  } = config

  // Create corestore for this identity
  const store = is_cli
    ? new Corestore(`./storage-identity-${name}`)
    : new Corestore(RAW(`identity-${name}`))

  // Global state for this identity instance
  const state = {
    events_drive: null,
    events_store: null,
    ds_manager: null,
    pairing_manager: null,
    swarm: null,
    dht: null,
    keypair: null,
    vault_bee: null, // Key-value store for vault data
    vault_audit: null, // Audit log for all vault operations
    network_store: null, // Store reference for vault operations
    pending_auth: null, // Pending authentication data (for pair mode)
    app_audits: new Map(), // app_id -> auditcore instance
    emitter: make_emitter()
  }

  // Store config for later use
  const vault_config = config

  // User auth promise, resolves when authentication completes
  let user_resolve, user_reject
  const user = new Promise((resolve, reject) => {
    user_resolve = resolve
    user_reject = reject
  })

  // Return vault object with all identity functions (app-independent only)
  const vault_api = {
    // Config for apps to access
    config: vault_config,
    // User promise (replaces login)
    user,
    authenticate,
    // Networking setup
    start_networking,
    // Vault-only pairing
    create_vault_invite,
    setup_vault_pairing,
    verify_vault_pairing,
    deny_vault_pairing,
    // Data structure management
    create_ds_manager,
    // Vault structure initialization (for apps to create vault in seed mode)
    init_vault_structures,
    // Events and device management (apps provide events_drive parameter)
    log_event,
    get_events,
    get_paired_devices,
    get_device_name,
    remove_device,
    // Debugging
    get_raw_data,
    // Setters
    set_events_drive,
    set_ds_manager,
    set_pairing_manager,
    set_swarm,
    set_dht,
    set_keypair,
    // Getters
    get_events_drive,
    get_events_store,
    get_store,
    get_swarm,
    get_dht,
    get_keypair,
    get_ds_manager,
    get_vault_bee,
    get_vault_audit,
    get_network_store,
    get_app_audit,
    // Vault API methods (with audit logging)
    register_app,
    load_app_audit,
    get_app,
    list_apps,
    vault_put,
    vault_get,
    vault_del,
    // Complete authentication (called by websys-ui after app join flow)
    complete_authentication,
    // Events
    on_update: handle_update_callback,
    on_vault_ready
  }
  return vault_api

  /***************************************
INTERNAL FUNCTIONS
***************************************/

  // Authenticate is called by the App's UI. It autheticates the user based on the mode.
  // If user is new, it resolves quickly. If not, it sets up networking to handle pairing.
  async function authenticate (auth_data) {
    const { username, mode, invite_code, on_verification_code } = auth_data
    try {
      if (mode === 'pair' && invite_code) {
        const invite_data = parse_vault_invite(invite_code)
        const topic = invite_data.topic ? b4a.from(invite_data.topic, 'hex') : null
        if (!topic) {
          if (user_reject) user_reject(new Error('Invite missing topic'))
          return
        }
        const networking_options = {
          name: username,
          store_name: `storage-${username}`,
          topic,
          relay: vault_config.relay
        }
        const { store: _network_store, swarm: swarm_instance } = await start_networking(networking_options)
        state.network_store = _network_store
        state.swarm = swarm_instance
        state.pairing_manager = pairing_manager_constructor(state.swarm)
        // Create vault structures FIRST using keys from invite
        // Pairing device will now only create structures once.
        await init_vault_structures({ store: state.network_store, vault_bee_key: invite_data.vault_bee_key, vault_audit_key: invite_data.vault_audit_key })
        // Now join pairing with the created structures
        const result = await state.pairing_manager.join_with_invite({
          invite_code,
          vault_bee: state.vault_bee,
          vault_audit: state.vault_audit,
          on_verification_code_ready: (code) => {
            if (on_verification_code) on_verification_code(code)
          }
        })
        state.pending_auth = {
          username: result.username || username,
          mode,
          store: state.network_store,
          swarm: state.swarm
        }
        state.emitter.emit('vault_ready', state.pending_auth)
        return
      }
      // Seed mode: resolve immediately, app will handle networking
      const authenticated_vault = {
        ...vault_api,
        username,
        mode,
        authenticated: true
      }
      if (user_resolve) user_resolve(authenticated_vault)
    } catch (err) {
      console.error('[identity] Authentication error:', err)
      if (user_reject) user_reject(err)
    }
  }

  function complete_authentication () {
    if (!state.pending_auth) return
    const authenticated_vault = {
      ...vault_api,
      username: state.pending_auth.username,
      mode: state.pending_auth.mode,
      authenticated: true,
      store: state.pending_auth.store,
      swarm: state.pending_auth.swarm
    }
    if (user_resolve) user_resolve(authenticated_vault)
    state.pending_auth = null
  }

  /***************************************
VAULT STRUCTURE INITIALIZATION
***************************************/

  async function init_vault_structures (options) {
    const { store, vault_bee_key, vault_audit_key } = options
    state.network_store = store
    state.vault_bee = create_autobee({
      store: store.namespace('vault-bee'),
      bootstrap: vault_bee_key ? b4a.from(vault_bee_key, 'hex') : null
    })
    state.vault_audit = create_auditcore({
      store: store.namespace('vault-audit'),
      bootstrap: vault_audit_key ? b4a.from(vault_audit_key, 'hex') : null
    })
    await state.vault_bee.ready()
    await state.vault_audit.ready()
  }

  /***************************************
VAULT PAIRING
***************************************/

  async function create_vault_invite (topic = null) {
    if (!state.vault_bee || !state.vault_audit) throw new Error('Vault not initialized')
    const vault_bee_key = b4a.toString(state.vault_bee.key, 'hex')
    const vault_audit_key = b4a.toString(state.vault_audit.key, 'hex')
    const invite_obj = BlindPairing.createInvite(state.vault_bee.key)
    const topic_hex = topic ? b4a.toString(topic, 'hex') : null
    const invite_data = { vault_bee_key, vault_audit_key, blind_invite: b4a.toString(invite_obj.invite, 'base64'), vault_only: true, topic: topic_hex }
    await state.vault_audit.append({ type: 'invite_created', data: { topic: topic_hex } })
    return {
      invite_code: b4a.toString(b4a.from(JSON.stringify(invite_data)), 'base64'),
      invite: invite_obj,
      vault_bee_key,
      vault_audit_key
    }
  }

  async function setup_vault_pairing (config) {
    if (!state.vault_bee || !state.vault_audit || !state.swarm) throw new Error('Vault not initialized')
    state.pairing_manager = pairing_manager_constructor(state.swarm)
    await state.pairing_manager.setup_member({ ...config, vault_bee: state.vault_bee, vault_audit: state.vault_audit })
    return state.pairing_manager
  }

  async function verify_vault_pairing (entered_code) {
    if (!state.pairing_manager) throw new Error('Pairing not setup')
    return state.pairing_manager.verify_and_complete_pairing({ entered_verification_code: entered_code, vault_bee: state.vault_bee, vault_audit: state.vault_audit })
  }

  function deny_vault_pairing () {
    if (!state.pairing_manager) throw new Error('Pairing not setup')
    state.pairing_manager.deny_pairing()
  }

  /***************************************
VAULT API OPERATIONS (with audit logging)
***************************************/

  async function audit_wrap (method, params, fn) {
    const version_before = state.vault_bee?.version || 0
    const result = await fn()
    if (state.vault_audit) await state.vault_audit.append({ type: 'vault_api', data: { method, params, version_before, version_after: state.vault_bee?.version || 0 } })
    return result
  }

  async function register_app (app_id, app_config) {
    if (!state.vault_bee) throw new Error('Vault not initialized')
    if (!state.network_store) throw new Error('Network store not initialized')
    return audit_wrap('register_app', { app_id }, handle_app_registration)
    async function handle_app_registration () {
      // Auto-create app auditcore (enforced by vault, not optional for apps)
      const app_audit = create_auditcore({
        store: state.network_store.namespace(`app-audit-${app_id}`)
      })
      await app_audit.ready()
      state.app_audits.set(app_id, app_audit)
      // Link app auditcore to vault's root auditcore
      if (state.vault_audit) {
        const audit_key = b4a.toString(app_audit.key, 'hex')
        await state.vault_audit.append({ type: 'app_audit_linked', data: { app_id, audit_key } })
      }
      // Store app config with audit key
      app_config.registered_at = Date.now()
      app_config.audit_key = b4a.toString(app_audit.key, 'hex')
      await state.vault_bee.put(`apps/${app_id}`, app_config)
      return { app_id, registered: true }
    }
  }

  // Load an existing app auditcore from bootstrap key (This is for the pairing Device)
  async function load_app_audit (app_id, audit_key) {
    if (!state.network_store) throw new Error('Network store not initialized')
    if (state.app_audits.has(app_id)) return state.app_audits.get(app_id)
    const app_audit = create_auditcore({
      store: state.network_store.namespace(`app-audit-${app_id}`),
      bootstrap: b4a.from(audit_key, 'hex')
    })
    await app_audit.ready()
    state.app_audits.set(app_id, app_audit)
    return app_audit
  }

  async function get_app (app_id) {
    if (!state.vault_bee) return null
    const entry = await state.vault_bee.get(`apps/${app_id}`)
    return entry?.value || null
  }

  async function list_apps () {
    if (!state.vault_bee) return []
    const apps = []
    for await (const entry of state.vault_bee.create_read_stream({ gte: 'apps/', lt: 'apps0' })) {
      apps.push({ id: entry.key.replace('apps/', ''), ...entry.value })
    }
    return apps
  }

  async function vault_put (key, value) {
    if (!state.vault_bee) throw new Error('Vault not initialized')
    return audit_wrap('vault_put', { key }, handle_vault_put)
    async function handle_vault_put () {
      await state.vault_bee.put(key, value)
      return { key, success: true }
    }
  }

  async function vault_get (key) {
    if (!state.vault_bee) return null
    const entry = await state.vault_bee.get(key)
    return entry?.value || null
  }

  async function vault_del (key) {
    if (!state.vault_bee) throw new Error('Vault not initialized')
    return audit_wrap('vault_del', { key }, handle_vault_del)
    async function handle_vault_del () {
      await state.vault_bee.del(key)
      return { key, deleted: true }
    }
  }

  /***************************************
EVENT LOGGING AND MANAGEMENT
***************************************/

  async function log_event (events_drive, type, data) {
    if (!events_drive) {
      console.warn(`[log_event] Cannot log ${type} event: events_drive not provided`)
      return
    }
    try {
      const event = {
        type,
        data,
        meta: {
          time: Date.now()
        }
      }
      const event_path = `/events/${event.meta.time}-${type}.json`
      await events_drive.put(event_path, b4a.from(JSON.stringify(event)))
    } catch (err) {
      console.error('Error logging event:', err)
    }
  }

  async function get_events (events_drive) {
    if (!events_drive) return []
    try {
      await events_drive.ready()
      const files = await events_drive.list('/events')
      return read_and_sort_events(events_drive, files)
    } catch (err) {
      console.error('Error getting events:', err)
      return []
    }
  }

  /***************************************
DEVICE MANAGEMENT
***************************************/

  async function get_paired_devices (events_drive_param) {
    const events = await get_events(events_drive_param)
    return build_paired_devices_list(events)
  }

  async function get_device_name (events_drive_param, metadata_writer_key) {
    const devices = await get_paired_devices(events_drive_param)
    const device = devices.find(d => d.metadata_writer === metadata_writer_key)
    return device ? device.name : null
  }

  // Remove device by removing writer access from all structures (dynamic)
  async function remove_device (events_drive_param, device) {
    if (!state.ds_manager) {
      console.error('Datastructure manager not initialized')
      return false
    }
    try {
      // Dynamically remove writers from ALL structures
      const structure_names = state.ds_manager.get_names()
      const removal_data = {}
      for (const name of structure_names) {
        const writer_key_name = `${name}_writer`
        const writer_key = device[writer_key_name]
        if (writer_key) {
          removal_data[writer_key_name] = writer_key
          try {
            await state.ds_manager.remove_writer(name, writer_key)
            console.log(`Removed writer from ${name}`)
          } catch (err) {
            console.warn(`Failed to remove writer from ${name}:`, err.message)
          }
        }
      }
      // Log the removal event with all writer keys
      await log_event(events_drive_param, 'remove', removal_data)
      console.log('Device removed successfully')
      state.emitter.emit('update')
      return true
    } catch (err) {
      console.error('Error removing device:', err)
      return false
    }
  }

  /***************************************
SHOW RAW DATA FOR THE UI. DYNAMIC WITH DS MANAGER
***************************************/

  async function get_raw_data (structure_name) {
    if (!state.ds_manager) return 'Datastructure manager not initialized'
    const structure = state.ds_manager.get(structure_name)
    if (!structure) return `Structure '${structure_name}' not found`
    const config = state.ds_manager.get_config(structure_name)
    return extract_raw_data(structure, config, structure_name)
  }

  /***************************************
SETTERS
***************************************/

  function set_events_drive (drive, store_instance, setup_callback) {
    state.events_drive = drive
    state.events_store = store_instance
    setup_callback?.()
    state.emitter.emit('update')
  }

  function create_ds_manager () { return datastructure_manager() }
  function set_ds_manager (manager) { state.ds_manager = manager }
  function set_pairing_manager (manager) { state.pairing_manager = manager }
  function set_swarm (swarm_instance) { state.swarm = swarm_instance }
  function set_dht (dht_instance) { state.dht = dht_instance }
  function set_keypair (keypair_instance) { state.keypair = keypair_instance }

  /***************************************
GETTERS
***************************************/

  function get_events_drive () { return state.events_drive }
  function get_events_store () { return state.events_store }
  function get_store () { return store }
  function get_swarm () { return state.swarm }
  function get_dht () { return state.dht }
  function get_keypair () { return state.keypair }
  function get_ds_manager () { return state.ds_manager }
  function get_vault_bee () { return state.vault_bee }
  function get_vault_audit () { return state.vault_audit }
  function get_network_store () { return state.network_store }
  function get_app_audit (app_id) { return state.app_audits.get(app_id) || null }

  /***************************************
EVENT EMITTER
***************************************/

  function handle_update_callback (cb) { return state.emitter.on('update', cb) }
  function on_vault_ready (cb) { return state.emitter.on('vault_ready', cb) }
}

/***************************************
GENERAL HELPER FUNCTIONS
***************************************/

/***************************************
START NETWORKING
***************************************/
async function start_networking (options = {}) {
  const name = options.name || 'peer'
  const topic = options.topic // App must provide topic
  const store_name = options.store_name || name // App can provide custom store name
  const get_primary_key = options.get_primary_key
  const get_primary_structure = options.get_primary_structure
  if (!topic) {
    throw new Error('start_networking requires a topic parameter')
  }
  // Use file system for CLI, indexed DB for browser
  const store = is_cli
    ? new Corestore(`./storage-${store_name}`)
    : new Corestore(RAW(store_name))
  await store.ready()
  // Offline mode - return store without networking
  if (options.offline_mode) {
    return { store, swarm: null, dht: null, cleanup: () => {} }
  }
  // CLI: Use same networking pattern as bare-peer
  if (is_cli) {
    const seedphrase = await load_mnemonic(name)
    const mnemonic_data = seedphrase
      ? await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise', mnemonic: seedphrase })
      : await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise' })
    if (!seedphrase) await save(mnemonic_data.mnemonic, name)
    const swarm = new Hyperswarm({ key_pair: mnemonic_data.keypair })
    swarm.on('connection', create_cli_connection_handler({ store, name, get_primary_key, keypair: mnemonic_data.keypair }))
    swarm.join(topic, { server: true, client: true })
    store.swarm = swarm
    return { store, swarm, dht: null, cleanup: () => swarm.destroy() }
  }
  // Browser: Original WebSocket relay code
  const is_dev = location.hostname === 'localhost' || location.hostname.startsWith('192.') || location.hostname.startsWith('10.')
  const relay_url = options.relay || (is_dev ? 'ws://localhost:8080' : 'wss://relay-production-9c0e.up.railway.app')
  console.log('[Identity] Using relay:', relay_url)
  await store.ready()
  return new Promise(init_socket)
  function init_socket (resolve, reject) {
    const socket = new WebSocket(relay_url)
    const resolved_state = { value: false }
    const error_handler = create_socket_error_handler({ resolved_state, relay_url, reject })
    socket.addEventListener('error', error_handler)
    socket.addEventListener('close', error_handler)
    socket.addEventListener('open', create_socket_open_handler({
      socket,
      resolved_state,
      name,
      relay_url,
      topic,
      store,
      get_primary_key,
      get_primary_structure,
      resolve,
      reject
    }))
  }
}

/***************************************
CREATE CLI CONNECTION HANDLER
***************************************/
function create_cli_connection_handler (config) {
  const { store, name, get_primary_key, keypair } = config
  return function handle_cli_connection (socket, info) {
    const peer_id = info.publicKey.toString('hex')
    console.log(`Connected to peer: ${peer_id.slice(0, 8)}`)
    const mux = new Protomux(socket)
    const { handlers, init_fn } = create_cli_protocol_handlers({ store, name, get_primary_key })
    const setup_protocol = identity_exchange_protocol(handlers, (send) => init_fn(send, keypair), {
      peer_mode: 'native',
      label: '[CLI]'
    })
    const channel = setup_protocol(mux)
    channel.open()
    store.replicate(socket)
  }
}

/***************************************
CREATE BROWSER CONNECTION HANDLER
***************************************/
function create_browser_connection_handler (config) {
  const { store, name, relay_url, mnemonic_data, get_primary_key, get_primary_structure, HyperWebRTC } = config
  return function handle_browser_connection (relay, details) {
    if (!relay.userData) relay.userData = null
    const mux = new Protomux(relay)
    const { handlers, init_fn } = create_browser_protocol_handlers({
      store,
      relay,
      name,
      relay_url,
      mnemonic_data,
      get_primary_key,
      HyperWebRTC
    })
    const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
      peer_mode: 'browser',
      label: '[browser-peer]'
    })
    const identity_channel = setup_protocol(mux)
    identity_channel.open()
    store.on('peer-add', handle_peer_add)
    relay.on('error', handle_relay_error)
    function handle_peer_add (peer) {
      if (get_primary_structure) {
        const structure = get_primary_structure()
        if (structure && structure.key) {
          store.emit('peer-autobase-key', {
            key: b4a.toString(structure.key, 'hex'),
            key_buffer: structure.key
          })
        }
      }
    }
    function handle_relay_error (err) {
      if (!err.message?.includes('Duplicate connection')) {
        console.warn('Relay error:', err.message)
      }
    }
  }
}

/***************************************
CREATE SOCKET ERROR HANDLER
***************************************/
function create_socket_error_handler (config) {
  const { resolved_state, relay_url, reject } = config
  return function handle_socket_error (err) {
    if (resolved_state.value) return
    resolved_state.value = true
    const message = err?.message || 'Connection error'
    reject(new Error(`Relay connection failed: ${relay_url} - ${message}`))
  }
}

/***************************************
CREATE SOCKET OPEN HANDLER
***************************************/
function create_socket_open_handler (config) {
  const { socket, resolved_state, name, relay_url, topic, store, get_primary_key, get_primary_structure, resolve, reject } = config
  return async function handle_socket_open () {
    try {
      if (resolved_state.value) return
      resolved_state.value = true
      if (socket.readyState !== WebSocket.OPEN) {
        console.error('Socket not ready:', socket.readyState)
        return
      }
      const seedphrase = await load_mnemonic(name)
      const mnemonic_data = seedphrase
        ? await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise', mnemonic: seedphrase })
        : await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise' })
      if (!seedphrase) await save(mnemonic_data.mnemonic, name)
      const stream = new Stream(true, socket)
      const dht = new DHT(stream)
      const swarm = new Hyperswarm({ dht, key_pair: mnemonic_data.keypair })
      swarm.on('connection', create_browser_connection_handler({
        store,
        name,
        relay_url,
        mnemonic_data: mnemonic_data.keypair,
        get_primary_key,
        get_primary_structure,
        HyperWebRTC
      }))
      console.log('Joining swarm')
      const discovery = swarm.join(topic, { server: true, client: true })
      const join_interval = setInterval(() => {
        swarm.join(topic, { server: true, client: true })
          .flushed()
          .catch((err) => console.warn('Join warning:', err.message))
      }, 5000)
      store.swarm = swarm
      resolve({
        store,
        swarm,
        dht,
        cleanup: () => clearInterval(join_interval)
      })
      discovery.flushed()
        .then(() => console.log('Swarm joined'))
        .catch((err) => console.warn('Flush warning:', err.message))
    } catch (error) {
      console.error('Error in socket open handler:', error)
      reject(error)
    }
  }
}

/***************************************
MAKE EMITTER
***************************************/
function make_emitter (state = {}) {
  return { on, off, emit }
  function on (type, callback) { (state[type] = state[type] || []).push(callback) }
  function off (type, callback) { (state[type] = state[type] || [])[state[type].indexOf(callback)] = undefined }
  function emit (type, data) {
    function handle_callback (f) {
      return f && f(data)
    }
    return (state[type] = state[type] || []).map(handle_callback)
  }
}

/***************************************
PARSE VAULT INVITE
***************************************/
function parse_vault_invite (invite_code) {
  let invite_data
  try {
    invite_data = JSON.parse(b4a.toString(b4a.from(invite_code, 'base64')))
  } catch (err) {
    throw new Error(`Invalid invite code: ${err.message}`)
  }
  if (!invite_data.vault_only) {
    throw new Error('Unsupported invite format')
  }
  return invite_data
}

/***************************************
READ AND SORT EVENTS
***************************************/
async function read_and_sort_events (events_drive, files) {
  const events = []
  for (const file of files) {
    try {
      const content = await events_drive.get(file)
      if (content) {
        events.push(JSON.parse(b4a.toString(content)))
      }
    } catch (err) {
      console.error('Error reading event file:', file, err)
    }
  }
  return events.sort((a, b) => a.meta.time - b.meta.time)
}

/***************************************
BUILD PAIRED DEVICES LIST
***************************************/
function build_paired_devices_list (events) {
  const devices_map = new Map()
  let device_counter = 0
  events.forEach(event => {
    const device_id = event.data.metadata_writer
    if (event.type === 'add') {
      devices_map.set(device_id, {
        name: `Device ${++device_counter}`,
        timestamp: event.meta.time,
        added_date: new Date(event.meta.time).toLocaleString(),
        ...Object.fromEntries(
          Object.entries(event.data).filter(([key]) => key.endsWith('_writer'))
        )
      })
    } else if (event.type === 'remove') {
      devices_map.delete(device_id)
    }
  })
  return Array.from(devices_map.values())
}

/***************************************
EXTRACT RAW DATA
***************************************/
async function extract_raw_data (structure, config, structure_name) {
  try {
    await structure.ready()
    if (config.type === 'autobase') return extract_indexed(structure.view, structure_name, 'Autobase', true)
    if (config.type === 'auditcore') return extract_indexed(structure, structure_name, 'Auditcore', false)
    if (config.type === 'autodrive') return extract_files(structure, structure_name)
    return `Unknown structure type: ${config.type}`
  } catch (err) {
    return `Error reading ${structure_name}: ${err.message}`
  }
}

async function extract_indexed (source, name, type, parse) {
  if (source.length === 0) return `${type} '${name}' is empty`
  const entries = []
  for (let i = 0; i < source.length; i++) {
    try {
      const data = parse ? JSON.parse(await source.get(i)) : await source.get(i)
      entries.push(`[${i}] ${JSON.stringify(data, null, 2)}`)
    } catch (err) {
      entries.push(`[${i}] Error: ${err.message}`)
    }
  }
  return entries.join('\n\n')
}

async function extract_files (drive, name) {
  try {
    const list = await drive.list('/')
    if (list.length === 0) return `Autodrive '${name}' is empty`
    const files = []
    for (const file of list) {
      try {
        const content = await drive.get(file)
        files.push(`${file}:\n${content ? b4a.toString(content) : 'null'}`)
      } catch (err) {
        files.push(`${file}: Error: ${err.message}`)
      }
    }
    return files.join('\n\n---\n\n')
  } catch (err) {
    return `List error: ${err.message}`
  }
}