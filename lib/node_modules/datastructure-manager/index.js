const b4a = require('b4a')
const { create_autodrive, get_local_core } = require('../autodrive')
const autobase = require('autobase')

// Datastructure manager. handles multiple data structures with unified API
// Supports: autobase (metadata), autodrive (files), (also handled pairing scenarios)

module.exports = datastructure_manager

function datastructure_manager (opts = {}) {
  const structures = new Map()
  const writer_keys = new Map() // namespace -> writer_key

  // For autobase we will use this opne and apply function
  const create_autobase_opts = (encoding = 'json', view_name = 'view') => ({
    valueEncoding: encoding,
    open: (store) => store.get({ name: view_name }),
    apply: async (batch, view, base) => {
      for (const entry of batch) {
        const { type, data = {} } = entry.value || {}
        if (type === 'addWriter') {
          const writer_key = b4a.from(data.key, 'hex')
          await base.addWriter(writer_key, { isIndexer: true })
        } else if (type) {
          await view.append(JSON.stringify(entry.value))
        }
      }
    }
  })

  // Register a new data structure
  const register = (config) => {
    const { name, namespace, type, store, autobase_opts, encoding, view_name } = config
    
    if (structures.has(name)) {
      throw new Error(`Datastructure '${name}' already registered`)
    }

    // Auto-generate autobase_opts if encoding/view_name provided
    let final_autobase_opts = autobase_opts
    if (type === 'autobase' && !autobase_opts && (encoding || view_name)) {
      final_autobase_opts = create_autobase_opts(encoding, view_name)
    }

    const structure = {
      name,
      namespace,
      type, // 'autobase' or 'autodrive'
      store: store.namespace(namespace),
      instance: null,
      writer_key: null,
      ready: false,
      autobase_opts: final_autobase_opts // Store custom or auto-generated options
    }

    structures.set(name, structure)
    return structure
  }

  // Initialize a structure (create instance)
  const init = async (name, bootstrap_key) => {
    const structure = structures.get(name)
    if (!structure) throw new Error(`Datastructure '${name}' not found`)

    // Convert bootstrap_key to Buffer if it's a hex string
    let key_buffer = null
    if (bootstrap_key) {
      key_buffer = Buffer.isBuffer(bootstrap_key) 
        ? bootstrap_key 
        : b4a.from(bootstrap_key, 'hex')
    }

    if (structure.type === 'autobase') {
      const opts = structure.autobase_opts || { valueEncoding: 'json' }
      structure.instance = new autobase(
        structure.store,
        key_buffer,
        opts
      )
    } else if (structure.type === 'autodrive') {
      structure.instance = create_autodrive({
        store: structure.store,
        bootstrap: key_buffer
      })
    }

    await structure.instance.ready()
    structure.ready = true
    structure.writer_key = structure.instance.key || structure.instance.base.key
    writer_keys.set(structure.namespace, structure.writer_key.toString('hex'))

    return structure.instance
  }

  // Get structure instance
  const get = (name) => {
    const structure = structures.get(name)
    return structure?.instance || null
  }

  // Get structure key
  const get_key = (name) => {
    const structure = structures.get(name)
    return structure?.writer_key ? structure.writer_key.toString('hex') : null
  }

  // Get structure store
  const get_store = (name) => {
    const structure = structures.get(name)
    return structure?.store || null
  }

  // Get all writer keys for pairing (returns object with namespace -> key)
  const get_all_writer_keys = () => {
    const keys = {}
    for (const [name, structure] of structures) {
      if (structure.writer_key) {
        keys[structure.namespace] = structure.writer_key.toString('hex')
      }
    }
    return keys
  }

  // Generate local writer keys for all structures (for pairing candidate)
  const generate_local_writer_keys = async (store) => {
    const keys = {}
    
    for (const [name, structure] of structures) {
      const namespaced_store = store.namespace(structure.namespace)
      const core = get_local_core({ store: namespaced_store })
      await core.ready()
      keys[structure.namespace] = core.key
      await core.close()
    }
    
    return keys
  }

  // Add writer to a structure
  const add_writer = async (name, writer_key) => {
    const structure = structures.get(name)
    if (!structure?.instance) throw new Error(`Datastructure '${name}' not initialized`)

    const key_hex = typeof writer_key === 'string' ? writer_key : writer_key.toString('hex')

    if (structure.type === 'autobase') {
      await structure.instance.append({ type: 'addWriter', data: { key: key_hex } })
      await structure.instance.update()
    } else if (structure.type === 'autodrive') {
      await structure.instance.add_writer(key_hex)
    }
  }

  // Remove writer from a structure
  const remove_writer = async (name, writer_key) => {
    const structure = structures.get(name)
    if (!structure?.instance) throw new Error(`Datastructure '${name}' not initialized`)

    const key_hex = typeof writer_key === 'string' ? writer_key : writer_key.toString('hex')

    if (structure.type === 'autobase') {
      await structure.instance.append({ type: 'removeWriter', data: { key: key_hex } })
      await structure.instance.update()
    } else if (structure.type === 'autodrive') {
      await structure.instance.remove_writer(key_hex)
    }
  }

  // Set structure instance (for when initialized externally)
  const set = (name, instance, writer_key) => {
    const structure = structures.get(name)
    if (!structure) throw new Error(`Datastructure '${name}' not found`)
    
    structure.instance = instance
    structure.ready = true
    
    if (writer_key) {
      structure.writer_key = typeof writer_key === 'string' ? b4a.from(writer_key, 'hex') : writer_key
      writer_keys.set(structure.namespace, structure.writer_key.toString('hex'))
    }
  }

  // Get all registered structure names
  const get_names = () => Array.from(structures.keys())

  // Get structure config
  const get_config = (name) => {
    const structure = structures.get(name)
    if (!structure) return null
    
    return {
      name: structure.name,
      namespace: structure.namespace,
      type: structure.type,
      ready: structure.ready,
      key: structure.writer_key ? structure.writer_key.toString('hex') : null
    }
  }

  // Get all structures config
  const get_all_configs = () => {
    return Array.from(structures.keys()).map(get_config)
  }

  // Create a peer structure (for subscribing to other peers)
  const create_peer_structure = async (name, peer_key, peer_key_buffer, store_instance) => {
    const structure = structures.get(name)
    if (!structure) throw new Error(`Datastructure '${name}' not found`)

    const peer_namespace = `peer-${structure.namespace}-${peer_key}`
    const peer_store = store_instance.namespace(peer_namespace)

    let peer_instance
    if (structure.type === 'autobase') {
      const autobase = require('autobase')
      const opts = structure.autobase_opts || create_autobase_opts()
      peer_instance = new autobase(peer_store, peer_key_buffer, opts)
    } else if (structure.type === 'autodrive') {
      const { create_autodrive } = require('../autodrive')
      peer_instance = create_autodrive({
        store: peer_store,
        bootstrap: peer_key_buffer
      })
    }

    await peer_instance.ready()
    return peer_instance
  }

  // ============================================================================
  // UNIVERSAL P2P APIs - for any app
  // ============================================================================

  // Initialize ALL structures at once (for new app instance)
  const init_all = async () => {
    const instances = {}
    for (const name of structures.keys()) {
      instances[name] = await init(name)
    }
    return instances
  }

  // Initialize ALL structures with bootstrap keys (for joining existing app)
  const init_all_with_keys = async (keys_map) => {
    // keys_map = { metadata: 'hex_key', drive: 'hex_key', ... }
    const instances = {}
    for (const [name, key] of Object.entries(keys_map)) {
      if (structures.has(name)) {
        instances[name] = await init(name, key)
      }
    }
    return instances
  }

  // Create invite with integrated pairing
  const create_invite_with_pairing = async (swarm, primary_structure_name) => {
    const pairing_manager_constructor = require('../pairing-manager')
    
    // Create ds_manager interface for pairing-manager
    const ds_manager_interface = {
      get_names,
      get_all_writer_keys,
      get_config,
      generate_local_writer_keys,
      get,
      get_key,
      add_writer
    }
    
    const pairing_manager = pairing_manager_constructor(ds_manager_interface, swarm)
    
    const primary_structure = structures.get(primary_structure_name)
    if (!primary_structure) throw new Error(`Primary structure '${primary_structure_name}' not found`)
    
    const primary_key = b4a.toString(primary_structure.writer_key, 'hex')
    const primary_autobase_key = structures.get('metadata')?.writer_key 
      ? b4a.toString(structures.get('metadata').writer_key, 'hex')
      : primary_key
    
    const result = await pairing_manager.create_invite(primary_key, primary_autobase_key)
    
    return { ...result, pairing_manager }
  }

  // Join with invite and initialize all structures
  const join_with_invite_and_init = async (invite_code, swarm, store_instance, on_verification_code_ready) => {
    const pairing_manager_constructor = require('../pairing-manager')
    
    // Create ds_manager interface for pairing-manager
    const ds_manager_interface = {
      get_names,
      get_all_writer_keys,
      get_config,
      generate_local_writer_keys,
      get,
      get_key,
      add_writer
    }
    
    const pairing_manager = pairing_manager_constructor(ds_manager_interface, swarm)
    
    const result = await pairing_manager.join_with_invite({ 
      invite_code, 
      store: store_instance,
      on_verification_code_ready
    })
    
    // Initialize ALL structures with keys received from pairing.
    const keys_map = result.all_structure_keys || {}
    
    const instances = await init_all_with_keys(keys_map)
    
    return { ...result, instances }
  }

  return {
    // Basic structure management
    register,
    init,
    get,
    get_key,
    get_store,
    
    // Writer management
    get_all_writer_keys,
    generate_local_writer_keys,
    add_writer,
    remove_writer,
    set,
    
    // Structure info
    get_names,
    get_config,
    get_all_configs,
    
    // Peer structures
    create_peer_structure,
    
    // Universal apis for all the apps
    init_all,
    init_all_with_keys,
    create_invite_with_pairing,
    join_with_invite_and_init
  }
}
