const b4a = require('b4a')
const { create_autodrive } = require('autodrive')
const { create_autobee } = require('autobee')
const { create_auditcore } = require('auditcore')
const autobase = require('autobase')

// Datastructure manager. handles multiple data structures with unified API
// Supports: autobase (metadata), autodrive (files), (also handled pairing scenarios)

module.exports = datastructure_manager

function datastructure_manager (opts = {}) {
  const structures = new Map()
  const writer_keys = new Map() // namespace -> writer_key

  const api = {
    // Basic structure management
    register,
    init,
    get,
    get_key,
    get_store,

    // Writer management
    add_writer,
    remove_writer,
    set,

    // Structure info
    get_names,
    get_config,
    get_all_configs,

    // Peer structures
    create_peer_structure,

    // Universal apis for all the apps
    init_all
  }

  return api

  // ============================================================================
  // Internal functions
  // ============================================================================

  // Register a new data structure
  function register (config) {
    const { name, namespace, type, store, encoding, view_name } = config

    if (structures.has(name)) {
      throw new Error(`Datastructure '${name}' already registered`)
    }

    const structure = {
      name,
      namespace,
      type, // 'autobase' or 'autodrive'
      store: store.namespace(namespace),
      encoding,
      view_name
    }

    structures.set(name, structure)
    return structure
  }

  // Initialize a structure (create instance)
  async function init (name, bootstrap_key) {
    const structure = structures.get(name)
    if (!structure) throw new Error(`Datastructure '${name}' not found`)

    // Convert bootstrap_key (hex string) to Buffer
    const key_buffer = bootstrap_key ? b4a.from(bootstrap_key, 'hex') : null

    if (structure.type === 'autobase') {
      const opts = (structure.encoding || structure.view_name)
        ? create_autobase_opts(structure.encoding, structure.view_name)
        : { valueEncoding: 'json' }

      structure.instance = new autobase(
        structure.store,
        key_buffer,
        opts
      )
    } else if (structure.type === 'autodrive') {
      structure.instance = create_autodrive({
        store: structure.store,
        bootstrap: key_buffer
      })
    } else if (structure.type === 'autobee') {
      structure.instance = create_autobee({
        store: structure.store,
        bootstrap: key_buffer,
        opts: {
          keyEncoding: structure.encoding || 'utf-8',
          valueEncoding: 'json'
        }
      })
    } else if (structure.type === 'auditcore') {
      structure.instance = create_auditcore({
        store: structure.store,
        bootstrap: key_buffer
      })
    }

    await structure.instance.ready()
    structure.ready = true
    structure.writer_key = structure.instance.key || structure.instance.base.key
    writer_keys.set(structure.namespace, structure.writer_key.toString('hex'))

    return structure.instance
  }

  // Get structure instance
  function get (name) {
    const structure = structures.get(name)
    return structure?.instance || null
  }

  // Get structure key
  function get_key (name) {
    const structure = structures.get(name)
    return structure?.writer_key ? structure.writer_key.toString('hex') : null
  }

  // Get structure store
  function get_store (name) {
    const structure = structures.get(name)
    return structure?.store || null
  }

  // Add writer to a structure
  async function add_writer (name, writer_key) {
    const structure = structures.get(name)
    if (!structure?.instance) throw new Error(`Datastructure '${name}' not initialized`)

    const key_hex = typeof writer_key === 'string' ? writer_key : writer_key.toString('hex')

    if (structure.type === 'autobase') {
      await structure.instance.append({ type: 'addWriter', data: { key: key_hex } })
      await structure.instance.update()
    } else if (structure.type === 'autodrive') {
      await structure.instance.add_writer(key_hex)
    } else if (structure.type === 'auditcore') {
      await structure.instance.add_writer(key_hex)
    }
  }

  // Remove writer from a structure
  async function remove_writer (name, writer_key) {
    const structure = structures.get(name)
    if (!structure?.instance) throw new Error(`Datastructure '${name}' not initialized`)

    const key_hex = typeof writer_key === 'string' ? writer_key : writer_key.toString('hex')

    if (structure.type === 'autobase') {
      await structure.instance.append({ type: 'removeWriter', data: { key: key_hex } })
      await structure.instance.update()
    } else if (structure.type === 'autodrive') {
      await structure.instance.remove_writer(key_hex)
    } else if (structure.type === 'auditcore') {
      await structure.instance.remove_writer(key_hex)
    }
  }

  // Set structure instance (for when initialized externally)
  function set (name, instance, writer_key) {
    const structure = structures.get(name)
    if (!structure) throw new Error(`Datastructure '${name}' not found`)

    structure.instance = instance
    structure.ready = true

    if (writer_key) {
      structure.writer_key = typeof writer_key === 'string' ? b4a.from(writer_key, 'hex') : writer_key
      writer_keys.set(structure.namespace, structure.writer_key.toString('hex'))
    }
  }

  // Get all registered structure names
  function get_names () {
    return Array.from(structures.keys())
  }

  // Get structure config
  function get_config (name) {
    const structure = structures.get(name)
    if (!structure) return null

    return {
      name: structure.name,
      namespace: structure.namespace,
      type: structure.type,
      encoding: structure.encoding,
      view_name: structure.view_name
    }
  }

  // Get all structures config
  function get_all_configs () {
    return Array.from(structures.keys()).map(get_config)
  }

  // Create a peer structure (for subscribing to other peers)
  async function create_peer_structure (name, peer_key, peer_key_buffer, store_instance) {
    const structure = structures.get(name)
    if (!structure) throw new Error(`Datastructure '${name}' not found`)

    const peer_namespace = `peer-${structure.namespace}-${peer_key}`
    const peer_store = store_instance.namespace(peer_namespace)

    let peer_instance
    if (structure.type === 'autobase') {
      const opts = create_autobase_opts(structure.encoding, structure.view_name)
      peer_instance = new autobase(peer_store, peer_key_buffer, opts)
    } else if (structure.type === 'autodrive') {
      peer_instance = create_autodrive({
        store: peer_store,
        bootstrap: peer_key_buffer
      })
    }

    await peer_instance.ready()
    return peer_instance
  }

  // ============================================================================
  // UNIVERSAL P2P APIs - for any app
  // ============================================================================

  // Initialize ALL structures at once
  async function init_all (structures_config, keys_map = null) {
    // Register all structures first
    for (const config of structures_config) {
      if (!structures.has(config.name)) {
        register(config)
      }
    }

    // Then initialize them with or without keys
    const instances = {}
    for (const config of structures_config) {
      const key = keys_map ? keys_map[config.name] : null
      instances[config.name] = await init(config.name, key)
    }
    return instances
  }
}

// ============================================================================
// GENERAL HELPER FUNCTIONS
// ============================================================================

// ============================================================================
// CREATE AUTOBASE OPTS (to tell Autobase how to handle data)
// ============================================================================

function create_autobase_opts (encoding = 'json', view_name = 'view') {
  return {
    valueEncoding: encoding,
    open: (store) => store.get({ name: view_name }),
    apply: async (batch, view, base) => {
      for (const entry of batch) {
        const { type, data = {} } = entry.value || {}
        if (type === 'addWriter') {
          const writer_key = b4a.from(data.key, 'hex')
          await base.addWriter(writer_key, { isIndexer: true })
        } else if (type) {
          await view.append(JSON.stringify(entry.value))
        }
      }
    }
  }
}
