# **Pairing Manager**

A simple module that handles **blind pairing** between devices so they can share writer keys for all your data structures.

## **What It Does**

* Secure key exchange for *every* registered data structure
* Supports any number of structures
* Handles **member** (owner) and **candidate** (joining device) roles
* Automatic writer-key sync once pairing succeeds

---

# **Usage**

```js
const pairing_manager = require('pairing-manager')
const manager = pairing_manager(ds_manager_interface, swarm)
```

* `ds_manager_interface` → functions for getting/adding writer keys
* `swarm` → your Hyperswarm instance

---

# **Member Side (main device)**

### **create_invite(primary_key, primary_autobase_key)**

Creates the invite code you’ll share with the joining device.

```js
const { invite_code, invite } = await manager.create_invite(
  primaryDriveKey,
  primaryAutobaseKey
)

console.log('Invite code:', invite_code)
```

You get:

* `invite_code` → share this
* `invite` → internal object for setup

---

### **setup_member({ ... })**

Listens for candidate devices and finishes pairing.

```js
await manager.setup_member({
  primary_discovery_key: Buffer.from('...'),
  invite,
  username: 'alice',
  on_paired: async (writer_keys) => {
    console.log('Device paired!', writer_keys)
  }
})
```

`on_paired` receives all new writer keys from the candidate in a `{ namespace: key }` object.

---

# **Candidate Side (device joining)**

### **join_with_invite({ invite_code, store })**

```js
const result = await manager.join_with_invite({
  invite_code: 'abc123...',
  store: corestore
})

console.log(result)
```

Returns something like:

```js
{
  all_structure_keys: {
    metadata_key: 'abc...',
    drive_key: 'def...',
    profile_key: 'ghi...'
  },
  username: 'alice'
}
```

Candidate then initializes all structures with these keys.

---

# **Cleanup**

```js
manager.close()
```

---

# **Full Pairing Flow**

### **Device 1 (Member)**

```js
const manager = pairing_manager(ds_manager_interface, swarm)

const { invite_code, invite } = await manager.create_invite(driveKey, autobaseKey)
console.log('Share this code:', invite_code)

await manager.setup_member({
  primary_discovery_key: drive.discoveryKey,
  invite,
  username: 'alice-laptop',
  on_paired: () => console.log('New device paired!')
})
```

### **Device 2 (Candidate)**

```js
const manager = pairing_manager(ds_manager_interface, swarm)

const result = await manager.join_with_invite({
  invite_code,
  store: my_corestore
})

console.log('Keys:', result.all_structure_keys)
```

---

# **Writer Key Exchange Behavior**

* Member sends its existing writer keys (namespaced)
* Candidate generates new writer keys for every structure
* Candidate sends them back
* Member receives them through `on_paired()`
* Both devices end up fully in sync

---

# **ds_manager_interface Requirements**

```js
{
  get_names,            // ['metadata', 'drive', ...]
  get_all_writer_keys,  // { 'namespace': key }
  get_config,           // config for each structure
  add_writer            // add writer key to structure
}
```

Simple and minimal — pairing manager doesn't care how you store things.

---

# **Security Notes**

* Uses the **blind pairing** protocol
* Invite codes are **one-time use**
* All traffic runs over encrypted Hyperswarm streams
* Member has to explicitly call `setup_member()` to accept pairing

---

# **Dependencies**

* `blind-pairing`
* `sodium-universal` (crypto)
* `b4a` (Buffer helpers)

