const b4a = require('b4a')
const BlindPairing = require('blind-pairing')
const extend = require('@geut/sodium-javascript-plus/extend')
const sodium = extend(require('sodium-universal'))
const crypto = require('hypercore-crypto')
const { get_local_core } = require('autodrive')

// Simplified pairing manager for vault-only pairing
// Only handles pairing of vault_bee and vault_audit structures
// Apps register post-pairing via vault API

module.exports = pairing_manager

function pairing_manager(swarm) {
  let current_member = null
  let current_candidate = null
  let pending_pairing_requests = []
  let multiple_attempts_detected = false

  const extract_verification_digits = (key_hex) => {
    const key_buffer = b4a.from(key_hex, 'hex')
    const discovery_key = crypto.discoveryKey(key_buffer)
    return b4a.toString(discovery_key, 'hex').slice(-6).toUpperCase()
  }

  const setup_member = async (config) => {
    const { vault_bee, vault_audit, invite, on_verification_needed, on_paired, username } = config

    const blind_pairing = new BlindPairing(swarm)
    await blind_pairing.ready()

    const vault_bee_discovery = crypto.discoveryKey(vault_bee.key)

    const handle_pairing_request = async (request) => {
      await request.open(invite.publicKey)

      const user_data = request.userData
      const vault_bee_writer = user_data.slice(0, 32)
      const vault_audit_writer = user_data.slice(32, 64)

      const verification_digits = extract_verification_digits(b4a.toString(vault_bee_writer, 'hex'))

      if (pending_pairing_requests.length > 0) {
        multiple_attempts_detected = true
      }

      const pairing_request_data = {
        request,
        vault_bee_writer,
        vault_audit_writer,
        verification_digits,
        invite_keypair: crypto.keyPair(invite.seed),
        on_paired,
        username,
        timestamp: Date.now()
      }

      pending_pairing_requests.push(pairing_request_data)

      if (pending_pairing_requests.length === 1 && on_verification_needed) {
        on_verification_needed(verification_digits)
      }

      return new Promise((resolve, reject) => {
        pairing_request_data.resolve = resolve
        pairing_request_data.reject = reject
      })
    }

    current_member = blind_pairing.addMember({
      discoveryKey: vault_bee_discovery,
      onadd: handle_pairing_request
    })

    await current_member.ready()
    current_member.announce()

    return current_member
  }

  const deny_all_requests = (except_index = -1) => {
    pending_pairing_requests.forEach((req, i) => {
      if (i === except_index) return
      try { req.request.deny(); req.resolve?.() } catch {}
    })
  }

  const verify_and_complete_pairing = async (config) => {
    const { entered_verification_code, vault_bee, vault_audit } = config

    const matched_index = pending_pairing_requests.findIndex(r => r.verification_digits === entered_verification_code)
    if (matched_index === -1) throw new Error('Verification code does not match any pending pairing request.')

    const { request, vault_bee_writer, vault_audit_writer, invite_keypair, on_paired, username, resolve } = pending_pairing_requests[matched_index]

    await vault_bee.add_writer(vault_bee_writer)
    await vault_audit.add_writer(vault_audit_writer)

    const pairing_data = { username, vault_bee_key: b4a.toString(vault_bee.key, 'hex'), vault_audit_key: b4a.toString(vault_audit.key, 'hex') }
    const additional_data = b4a.from(JSON.stringify(pairing_data))

    request.confirm({
      key: vault_bee.key,
      encryptionKey: vault_audit.key,
      additional: { data: additional_data, signature: crypto.sign(additional_data, invite_keypair.secretKey) }
    })

    if (on_paired) await on_paired({ vault_bee_writer: b4a.toString(vault_bee_writer, 'hex'), vault_audit_writer: b4a.toString(vault_audit_writer, 'hex') })
    resolve?.()

    const result = { success: true, multiple_attempts: multiple_attempts_detected, total_attempts: pending_pairing_requests.length }
    deny_all_requests(matched_index)
    pending_pairing_requests = []
    multiple_attempts_detected = false
    return result
  }

  const deny_pairing = () => {
    if (pending_pairing_requests.length === 0) throw new Error('No pending pairing request')
    deny_all_requests()
    pending_pairing_requests = []
    multiple_attempts_detected = false
  }

  const join_with_invite = async (config) => {
    const { invite_code, store, on_verification_code_ready } = config

    let invite_data
    try {
      invite_data = JSON.parse(b4a.toString(b4a.from(invite_code, 'base64')))
    } catch (err) {
      throw new Error(`Invalid invite code: ${err.message}`)
    }

    if (!invite_data.vault_only) {
      throw new Error('Expected vault-only invite')
    }

    const blind_pairing = new BlindPairing(swarm)
    await blind_pairing.ready()

    const invite_buffer = b4a.from(invite_data.blind_invite, 'base64')

    const vault_bee_store = store.namespace('vault-bee')
    const vault_bee_core = get_local_core({ store: vault_bee_store })
    await vault_bee_core.ready()
    const vault_bee_writer = vault_bee_core.key

    const vault_audit_store = store.namespace('vault-audit')
    const vault_audit_core = get_local_core({ store: vault_audit_store })
    await vault_audit_core.ready()
    const vault_audit_writer = vault_audit_core.key

    const verification_digits = extract_verification_digits(b4a.toString(vault_bee_writer, 'hex'))
    if (on_verification_code_ready) {
      on_verification_code_ready(verification_digits)
    }

    const user_data = b4a.concat([vault_bee_writer, vault_audit_writer])

    return new Promise((resolve, reject) => {
      const handle_add = async (result) => {
        let username = null, vault_bee_key = null, vault_audit_key = null
        if (result.data) {
          try {
            const data = JSON.parse(b4a.toString(result.data))
            username = data.username
            vault_bee_key = data.vault_bee_key
            vault_audit_key = data.vault_audit_key
          } catch {}
        }
        await vault_bee_core.close()
        await vault_audit_core.close()
        resolve({ username, vault_bee_key, vault_audit_key, vault_bee_writer: b4a.toString(vault_bee_writer, 'hex'), vault_audit_writer: b4a.toString(vault_audit_writer, 'hex') })
      }

      current_candidate = blind_pairing.addCandidate({
        invite: invite_buffer,
        userData: user_data,
        onadd: handle_add
      })

      current_candidate.request.on('rejected', () => reject(new Error('Pairing denied by user')))
      current_candidate.ready().catch(reject)
    })
  }

  // Close pairing
  const close = async () => {
    if (current_member) {
      await current_member.close()
      current_member = null
    }
    if (current_candidate) {
      await current_candidate.close()
      current_candidate = null
    }
    pending_pairing_requests = []
    multiple_attempts_detected = false
  }

  const get_pending_verification_digits = () => {
    return pending_pairing_requests.length > 0 ? pending_pairing_requests[0].verification_digits : null
  }

  const get_pending_requests_count = () => pending_pairing_requests.length

  const has_multiple_attempts = () => multiple_attempts_detected

  return {
    setup_member,
    verify_and_complete_pairing,
    deny_pairing,
    join_with_invite,
    close,
    get_pending_verification_digits,
    get_pending_requests_count,
    has_multiple_attempts,
    extract_verification_digits
  }
}

