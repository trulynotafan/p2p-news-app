const b4a = require('b4a')
const BlindPairing = require('blind-pairing')
const extend = require('@geut/sodium-javascript-plus/extend')
const sodium = extend(require('sodium-universal'))

// Pairing manager. handles blind pairing for all data structures
// works with datastructure manager to pair all registered structures (dynamic)

module.exports = pairing_manager

function pairing_manager (ds_manager, swarm) {
  let current_member = null
  let current_candidate = null
  let pending_pairing_requests = []  // Array to store ALL incoming pairing requests
  let multiple_attempts_detected = false  // Flag to notify user of unusual behavior

  // Extract 6 digits from a writer key (last 6 hex chars = 3 bytes)
  const extract_verification_digits = (writer_key_hex) => {
    return writer_key_hex.slice(-6).toUpperCase()
  }

  // Create invite for pairing (member side)
  const create_invite = async (primary_key, primary_autobase_key) => {
    const all_keys = ds_manager.get_all_writer_keys()
    
    // Create invite with primary drive key
    const key_buffer = b4a.from(primary_key, 'hex')
    const invite_obj = BlindPairing.createInvite(key_buffer)
    const invite_code = b4a.toString(invite_obj.invite, 'base64')
    
    return {
      invite_code,
      invite: invite_obj,
      autobase_key: primary_autobase_key,
      all_keys
    }
  }

  // Setup member to handle pairing requests
  const setup_member = async (config) => {
    const { primary_discovery_key, invite, on_paired, on_verification_needed, username } = config
    const crypto = require('hypercore-crypto')
    
    const blind_pairing = new BlindPairing(swarm)
    await blind_pairing.ready()

    const handle_pairing_request = async (request) => {
      try {
        await request.open(invite.publicKey)

        const user_data = request.userData
        const structure_names = ds_manager.get_names()
        
        // Extract writer keys from user_data (32 bytes each)
        const writer_keys = {}
        let key_offset = 0
        
        for (const name of structure_names) {
          const config = ds_manager.get_config(name)
          const key_buffer = user_data.slice(key_offset, key_offset + 32)
          writer_keys[config.namespace] = b4a.toString(key_buffer, 'hex')
          key_offset += 32
        }

        // Extract verification digits from the candidate's metadata writer key
        const candidate_metadata_writer = writer_keys[ds_manager.get_config('metadata').namespace]
        const verification_digits = extract_verification_digits(candidate_metadata_writer)
        
        // Check if we already have pending requests - if so, mark multiple attempts
        if (pending_pairing_requests.length > 0) {
          multiple_attempts_detected = true
        }
        
        // Store this pairing request (store ALL requests, not just first)
        const pairing_request_data = {
          writer_keys,
          request,
          verification_digits,
          invite_keypair: crypto.keyPair(invite.seed),
          on_paired,
          username,
          timestamp: Date.now()
        }
        
        pending_pairing_requests.push(pairing_request_data)
        
        // Notify UI that verification is needed (only for first request)
        if (pending_pairing_requests.length === 1 && on_verification_needed) {
          on_verification_needed(verification_digits)
        }
        
        // Return a promise that resolves when verification is complete
        return new Promise((resolve, reject) => {
          pairing_request_data.resolve_verification = resolve
          pairing_request_data.reject_verification = reject
        })
      } catch (error) {
        console.error('[pairing-manager] Pairing request error:', error.message)
        throw error
      }
    }

    current_member = blind_pairing.addMember({
      discoveryKey: primary_discovery_key,
      onadd: handle_pairing_request
    })

    await current_member.ready()
    current_member.announce()
    
    return current_member
  }

  // Verify the code entered by user and complete pairing
  const verify_and_complete_pairing = async (config) => {
    const { entered_verification_code } = config
    const crypto = require('hypercore-crypto')
    
    if (pending_pairing_requests.length === 0) {
      throw new Error('No pending pairing requests')
    }
    
    // Try to find a matching request
    let matched_request = null
    let matched_index = -1
    
    for (let i = 0; i < pending_pairing_requests.length; i++) {
      if (entered_verification_code === pending_pairing_requests[i].verification_digits) {
        matched_request = pending_pairing_requests[i]
        matched_index = i
        break
      }
    }
    
    // If no match found, throw error (user can try again)
    if (!matched_request) {
      throw new Error('Verification code does not match any pending pairing request. Please try again.')
    }
    
    // Code matches, complete the pairing with the matched request
    const { writer_keys, request, invite_keypair, on_paired, username } = matched_request
    const structure_names = ds_manager.get_names()
    
    // Add writers to all structures
    for (const name of structure_names) {
      const config = ds_manager.get_config(name)
      await ds_manager.add_writer(name, writer_keys[config.namespace])
    }

    // Prepare ALL structure keys + username to send via additional data
    const pairing_data = {
      username: username,
      keys: {}
    }
    
    for (const name of structure_names) {
      pairing_data.keys[name] = ds_manager.get_key(name)
    }
    
    // Encode additional data as JSON
    const additional_data = b4a.from(JSON.stringify(pairing_data))
    
    // Sign the additional data with the invite's keypair
    const signature = crypto.sign(additional_data, invite_keypair.secretKey)
    
    // Find drive and metadata names
    const drive_name = structure_names.find(n => 
      ds_manager.get_config(n).namespace === 'blog-files'
    )
    const metadata_name = structure_names.find(n => 
      ds_manager.get_config(n).namespace === 'blog-metadata'
    )
    
    request.confirm({
      key: b4a.from(ds_manager.get_key(drive_name), 'hex'),
      encryptionKey: b4a.from(ds_manager.get_key(metadata_name), 'hex'),
      additional: {
        data: additional_data,
        signature: signature
      }
    })
    
    if (on_paired) {
      await on_paired(writer_keys)
    }
    
    // Resolve the matched request's promise
    if (matched_request.resolve_verification) {
      matched_request.resolve_verification()
    }
    
    // Deny all other non-matching requests
    for (let i = 0; i < pending_pairing_requests.length; i++) {
      if (i !== matched_index) {
        const req = pending_pairing_requests[i]
        try {
          req.request.deny()
          if (req.resolve_verification) req.resolve_verification()
        } catch (err) {
          console.error('[pairing-manager] Error denying request:', err.message)
        }
      }
    }
    
    // Prepare result with multiple attempts info
    const had_multiple_attempts = multiple_attempts_detected
    const total_attempts = pending_pairing_requests.length
    
    // Clear all pending requests
    pending_pairing_requests = []
    multiple_attempts_detected = false
    
    // Return info about multiple attempts if detected
    return {
      success: true,
      multiple_attempts: had_multiple_attempts,
      total_attempts: total_attempts
    }
  }

  // Deny all pending pairing requests
  const deny_pairing = () => {
    if (pending_pairing_requests.length === 0) {
      throw new Error('No pending pairing requests')
    }
    
    // Deny all pending requests
    for (const req of pending_pairing_requests) {
      try {
        req.request.deny()
        if (req.resolve_verification) {
          req.resolve_verification()
        }
      } catch (err) {
        console.error('[pairing-manager] Error denying request:', err.message)
      }
    }
    
    // Clear all pending requests
    pending_pairing_requests = []
    multiple_attempts_detected = false
  }

  // Join with invite (candidate side)
  const join_with_invite = async (config) => {
    const { invite_code, store, on_verification_code_ready } = config
    
    const blind_pairing = new BlindPairing(swarm)
    await blind_pairing.ready()

    const invite_buffer = b4a.from(invite_code, 'base64')

    // Generate local writer keys for all structures
    const local_keys = await ds_manager.generate_local_writer_keys(store)
    
    // Concatenate all writer keys in order
    const structure_names = ds_manager.get_names()
    const key_buffers = structure_names.map(name => {
      const config = ds_manager.get_config(name)
      return local_keys[config.namespace]
    })
    
    // Extract verification digits from metadata writer key (for Device B to display)
    const metadata_namespace = ds_manager.get_config('metadata').namespace
    const metadata_writer_key = local_keys[metadata_namespace]
    const metadata_writer_hex = b4a.toString(metadata_writer_key, 'hex')
    const verification_digits = extract_verification_digits(metadata_writer_hex)
    
    // Call callback immediately with verification code so UI can display it
    if (on_verification_code_ready) {
      on_verification_code_ready(verification_digits)
    }
    
    // Send only writer keys (no verification code)
    const user_data = b4a.concat(key_buffers)

    return new Promise((resolve, reject) => {
      let resolved_or_rejected = false
      
      const handle_candidate_add = async (result) => {
        try {
          if (resolved_or_rejected) return
          resolved_or_rejected = true
          
          // Extract username and ALL structure keys from additional data
          let username = null
          let all_keys = {}
          if (result.data) {
            try {
              const pairing_data = JSON.parse(b4a.toString(result.data))
              username = pairing_data.username
              all_keys = pairing_data.keys
            } catch (err) {
              console.error('[pairing-manager] Error parsing pairing data:', err.message)
            }
          }
          
          resolve({
            drive_key: result.key,
            autobase_key: result.encryptionKey,
            username: username,
            all_structure_keys: all_keys
          })
        } catch (error) {
          console.error('[pairing-manager] Join error:', error.message)
          if (!resolved_or_rejected) {
            resolved_or_rejected = true
            reject(error)
          }
        }
      }

      const handle_candidate_ready_error = (error) => {
        console.error('[pairing-manager] Candidate ready error:', error.message)
        if (!resolved_or_rejected) {
          resolved_or_rejected = true
          reject(error)
        }
      }

      current_candidate = blind_pairing.addCandidate({
        invite: invite_buffer,
        userData: user_data,
        onadd: handle_candidate_add
      })

      // Listen for rejection from member
      current_candidate.request.on('rejected', (err) => {
        if (!resolved_or_rejected) {
          resolved_or_rejected = true
          reject(new Error('Pairing denied by user'))
        }
      })

      // Wait for candidate to be ready
      current_candidate.ready()
        .catch(handle_candidate_ready_error)
    })
  }

  // Close pairing
  const close = async () => {
    if (current_member) {
      await current_member.close()
      current_member = null
    }
    if (current_candidate) {
      await current_candidate.close()
      current_candidate = null
    }
  }

  // Get pending verification digits (for UI to show input box)
  const get_pending_verification_digits = () => {
    return pending_pairing_requests.length > 0 ? pending_pairing_requests[0].verification_digits : null
  }
  
  // Get count of pending pairing requests
  const get_pending_requests_count = () => pending_pairing_requests.length
  
  // Check if multiple attempts were detected
  const has_multiple_attempts = () => multiple_attempts_detected

  return {
    create_invite,
    setup_member,
    verify_and_complete_pairing,
    deny_pairing,
    join_with_invite,
    close,
    get_pending_verification_digits,
    get_pending_requests_count,
    has_multiple_attempts
  }
}

