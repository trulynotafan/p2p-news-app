const b4a = require('b4a')
const BlindPairing = require('blind-pairing')
const extend = require('@geut/sodium-javascript-plus/extend')
const sodium = extend(require('sodium-universal'))
const crypto = require('hypercore-crypto')
const { get_local_core } = require('autodrive')

// Simplified pairing manager for vault-only pairing
// Only handles pairing of vault_bee and vault_audit structures
// Apps register post-pairing via vault API

module.exports = pairing_manager

function pairing_manager (swarm) {
  let current_member = null
  let current_candidate = null
  let pending_pairing_requests = []
  let multiple_attempts_detected = false

  const api = {
    setup_member,
    verify_and_complete_pairing,
    deny_pairing,
    join_with_invite,
    close,
    get_pending_verification_digits,
    get_pending_requests_count,
    has_multiple_attempts,
    extract_verification_digits
  }
  return api

/***************************************
INTERNAL FUNCTIONS
***************************************/

/***************************************
SETUP MEMBER AKA The host device
***************************************/
  async function setup_member (config) {
    const { vault_bee, invite, on_verification_needed, on_paired, username } = config
    const blind_pairing = new BlindPairing(swarm)
    await blind_pairing.ready()
    const vault_bee_discovery = crypto.discoveryKey(vault_bee.key)
    async function handle_pairing_request (request) {
      await request.open(invite.publicKey)
      const user_data = request.userData
      const vault_bee_writer = user_data.slice(0, 32)
      const vault_audit_writer = user_data.slice(32, 64)
      const verification_digits = extract_verification_digits(b4a.toString(vault_bee_writer, 'hex'))
      if (pending_pairing_requests.length > 0) {
        multiple_attempts_detected = true
      }
      const pairing_request_data = {
        request,
        vault_bee_writer,
        vault_audit_writer,
        verification_digits,
        invite_keypair: crypto.keyPair(invite.seed),
        on_paired,
        username,
        timestamp: Date.now()
      }
      pending_pairing_requests.push(pairing_request_data)
      if (pending_pairing_requests.length === 1 && on_verification_needed) {
        on_verification_needed(verification_digits)
      }
      return new Promise(store_pairing_promise)
      function store_pairing_promise (resolve, reject) {
        pairing_request_data.resolve = resolve
        pairing_request_data.reject = reject
      }
    }
    current_member = blind_pairing.addMember({
      discoveryKey: vault_bee_discovery,
      onadd: handle_pairing_request
    })
    await current_member.ready()
    current_member.announce()
    return current_member
  }

/***************************************
VERIFY AND COMPLETE PAIRING. After pasting the one time code.
***************************************/
  async function verify_and_complete_pairing (config) {
    const { entered_verification_code, vault_bee, vault_audit } = config
    const matched_index = pending_pairing_requests.findIndex(function (r) { return r.verification_digits === entered_verification_code })
    if (matched_index === -1) throw new Error('Verification code does not match any pending pairing request.')
    const { request, vault_bee_writer, vault_audit_writer, invite_keypair, on_paired, username, resolve } = pending_pairing_requests[matched_index]
    await vault_bee.add_writer(vault_bee_writer)
    await vault_audit.add_writer(vault_audit_writer)
    const additional = build_pairing_confirmation_data(vault_bee.key, vault_audit.key, invite_keypair.secretKey, username)
    request.confirm({
      key: vault_bee.key,
      encryptionKey: vault_audit.key,
      additional
    })
    if (on_paired) await on_paired({ vault_bee_writer: b4a.toString(vault_bee_writer, 'hex'), vault_audit_writer: b4a.toString(vault_audit_writer, 'hex') })
    resolve?.()
    const result = { success: true, multiple_attempts: multiple_attempts_detected, total_attempts: pending_pairing_requests.length }
    // Explicitly pass the state array to the helper
    deny_all_requests(pending_pairing_requests, matched_index)
    pending_pairing_requests = []
    multiple_attempts_detected = false
    return result
  }

/***************************************
DENY PAIRING
***************************************/
  function deny_pairing () {
    if (pending_pairing_requests.length === 0) throw new Error('No pending pairing request')
    // Explicitly pass the state array to the helper
    deny_all_requests(pending_pairing_requests)
    pending_pairing_requests = []
    multiple_attempts_detected = false
  }

/***************************************
JOIN WITH INVITE FOR CANDIDATE DEVICE
***************************************/
  async function join_with_invite (config) {
    const { invite_code, vault_bee, vault_audit, on_verification_code_ready } = config
    const invite_data = parse_vault_invite(invite_code)
    const blind_pairing = new BlindPairing(swarm)
    await blind_pairing.ready()
    const invite_buffer = b4a.from(invite_data.blind_invite, 'base64')
    // Get writer keys from the already-created vault structures
    // No need to create any local cores here.
    const vault_bee_writer = vault_bee.base.local.key
    const vault_audit_writer = vault_audit.base.local.key
    const verification_digits = extract_verification_digits(b4a.toString(vault_bee_writer, 'hex'))
    if (on_verification_code_ready) {
      on_verification_code_ready(verification_digits)
    }
    const user_data = b4a.concat([vault_bee_writer, vault_audit_writer])
    return new Promise(store_candidate_promise)
    function store_candidate_promise (resolve, reject) {
      async function handle_add (result) {
        const parsed = parse_pairing_result(result)
        resolve({
          username: parsed.username,
          vault_bee_writer: b4a.toString(vault_bee_writer, 'hex'),
          vault_audit_writer: b4a.toString(vault_audit_writer, 'hex')
        })
      }
      current_candidate = blind_pairing.addCandidate({
        invite: invite_buffer,
        userData: user_data,
        onadd: handle_add
      })
      current_candidate.request.on('rejected', handle_pairing_rejection)
      current_candidate.ready().catch(reject)
      function handle_pairing_rejection () {
        reject(new Error('Pairing denied by user'))
      }
    }
  }

/***************************************
CLOSE PAIRING
***************************************/
  async function close () {
    if (current_member) {
      await current_member.close()
      current_member = null
    }
    if (current_candidate) {
      await current_candidate.close()
      current_candidate = null
    }
    pending_pairing_requests = []
    multiple_attempts_detected = false
  }

/***************************************
GET PENDING VERIFICATION DIGITS
***************************************/
  function get_pending_verification_digits () {
    return pending_pairing_requests.length > 0 ? pending_pairing_requests[0].verification_digits : null
  }

/***************************************
GET PENDING REQUESTS COUNT
***************************************/
  function get_pending_requests_count () {
    return pending_pairing_requests.length
  }

/***************************************
HAS MULTIPLE ATTEMPTS
***************************************/
  function has_multiple_attempts () {
    return multiple_attempts_detected
  }
}

/***************************************
GENERAL HELPER FUNCTIONS
***************************************/

/***************************************
EXTRACT VERIFICATION DIGITS
***************************************/
function extract_verification_digits (key_hex) {
  const key_buffer = b4a.from(key_hex, 'hex')
  const discovery_key = crypto.discoveryKey(key_buffer)
  return b4a.toString(discovery_key, 'hex').slice(-6).toUpperCase()
}

/***************************************
DENY ALL REQUESTS
***************************************/
function deny_all_requests (pending_requests, except_index = -1) {
  pending_requests.forEach(function (req, i) {
    if (i === except_index) return
    try { req.request.deny(); req.resolve?.() } catch {}
  })
}

/***************************************
PARSE VAULT INVITE
***************************************/
function parse_vault_invite (invite_code) {
  let invite_data
  try {
    invite_data = JSON.parse(b4a.toString(b4a.from(invite_code, 'base64')))
  } catch (err) {
    throw new Error(`Invalid invite code: ${err.message}`)
  }
  if (!invite_data.vault_only) {
    throw new Error('Expected vault-only invite')
  }
  return invite_data
}

/***************************************
BUILD PAIRING CONFIRMATION DATA
***************************************/
function build_pairing_confirmation_data (vault_bee_key, vault_audit_key, invite_secret_key, username) {
  const pairing_data = { username, vault_bee_key: b4a.toString(vault_bee_key, 'hex'), vault_audit_key: b4a.toString(vault_audit_key, 'hex') }
  const additional_data = b4a.from(JSON.stringify(pairing_data))
  return {
    data: additional_data,
    signature: crypto.sign(additional_data, invite_secret_key)
  }
}

/***************************************
PARSE PAIRING RESULT
***************************************/
function parse_pairing_result (result) {
  let username = null; let vault_bee_key = null; let vault_audit_key = null
  if (result.data) {
    try {
      const data = JSON.parse(b4a.toString(result.data))
      username = data.username
      vault_bee_key = data.vault_bee_key
      vault_audit_key = data.vault_audit_key
    } catch {}
  }
  return { username, vault_bee_key, vault_audit_key }
}