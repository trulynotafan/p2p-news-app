// Vault operations module - vault data API, event logging, device management, raw data
// Provides audited vault read/write, event tracking, and device management
// Used by identity module with state accessors passed in

const b4a = require('b4a')
const { create_auditcore } = require('auditcore')

module.exports = { create_vault_ops, make_emitter, parse_vault_invite }

function create_vault_ops (get_state) {
  const api = {
    // Vault API (audited read/write)
    audit_wrap,
    register_app,
    load_app_audit,
    get_app,
    list_apps,
    vault_put,
    vault_get,
    vault_del,
    // Event logging
    log_event,
    get_events,
    // Device management
    get_paired_devices,
    get_device_name,
    remove_device,
    // Writer access management
    start_writer_watcher,
    request_writer_access,
    wait_for_writer_access,
    log_bootstrap_device,
    // Raw data inspection
    get_raw_data
  }
  return api

  /***************************************
  VAULT API OPERATIONS (with audit logging)
  ***************************************/

  /***************************************
  Wraping each operation with audit log
  ***************************************/

  async function audit_wrap (method, params, fn) {
    const state = get_state()
    const version_before = state.vault_bee?.version || 0
    const result = await fn()
    if (state.vault_audit) await state.vault_audit.append({ type: 'vault_api', data: { method, params, version_before, version_after: state.vault_bee?.version || 0 } })
    return result
  }

  /***************************************
  Registering a specifc app
  ***************************************/

  async function register_app (app_id, app_config) {
    const state = get_state()
    if (!state.vault_bee) throw new Error('Vault not initialized')
    if (!state.network_store) throw new Error('Network store not initialized')
    return audit_wrap('register_app', { app_id }, handle_app_registration)
    async function handle_app_registration () {
      const app_audit = create_auditcore({
        store: state.network_store.namespace(`app-audit-${app_id}`)
      })
      await app_audit.ready()
      state.app_audits.set(app_id, app_audit)
      if (state.vault_audit) {
        const audit_key = b4a.toString(app_audit.key, 'hex')
        await state.vault_audit.append({ type: 'app_audit_linked', data: { app_id, audit_key } })
      }
      app_config.registered_at = Date.now()
      app_config.audit_key = b4a.toString(app_audit.key, 'hex')
      await state.vault_bee.put(`apps/${app_id}`, app_config)
      return { app_id, registered: true }
    }
  }

  /***************************************
  Create App-specifc Audit core
  ***************************************/

  async function load_app_audit (app_id, audit_key) {
    const state = get_state()
    if (!state.network_store) throw new Error('Network store not initialized')
    if (state.app_audits.has(app_id)) return state.app_audits.get(app_id)
    const app_audit = create_auditcore({
      store: state.network_store.namespace(`app-audit-${app_id}`),
      bootstrap: b4a.from(audit_key, 'hex')
    })
    await app_audit.ready()
    state.app_audits.set(app_id, app_audit)
    return app_audit
  }

  /***************************************
  Get a Specifc App
  ***************************************/

  async function get_app (app_id) {
    const state = get_state()
    if (!state.vault_bee) return null
    const entry = await state.vault_bee.get(`apps/${app_id}`)
    return entry?.value || null
  }

  /***************************************
  List all the available Apps
  ***************************************/

  async function list_apps () {
    const state = get_state()
    if (!state.vault_bee) return []
    const apps = []
    for await (const entry of state.vault_bee.create_read_stream({ gte: 'apps/', lt: 'apps0' })) {
      apps.push({ id: entry.key.replace('apps/', ''), ...entry.value })
    }
    return apps
  }

  /***************************************
  VAULT general operations
  ***************************************/

  async function vault_put (key, value) {
    const state = get_state()
    if (!state.vault_bee) throw new Error('Vault not initialized')
    return audit_wrap('vault_put', { key }, handle_vault_put)
    async function handle_vault_put () {
      await state.vault_bee.put(key, value)
      return { key, success: true }
    }
  }

  async function vault_get (key) {
    const state = get_state()
    if (!state.vault_bee) return null
    const entry = await state.vault_bee.get(key)
    return entry?.value || null
  }

  async function vault_del (key) {
    const state = get_state()
    if (!state.vault_bee) throw new Error('Vault not initialized')
    return audit_wrap('vault_del', { key }, handle_vault_del)
    async function handle_vault_del () {
      await state.vault_bee.del(key)
      return { key, deleted: true }
    }
  }

  /***************************************
  EVENT LOGGING AND MANAGEMENT
  ***************************************/

  async function log_event (events_drive, type, data) {
    if (!events_drive) {
      console.warn(`[log_event] Cannot log ${type} event: events_drive not provided`)
      return
    }
    try {
      const event = { type, data, meta: { time: Date.now() } }
      const event_path = `/events/${event.meta.time}-${type}.json`
      await events_drive.put(event_path, b4a.from(JSON.stringify(event)))
    } catch (err) {
      console.error('Error logging event:', err)
    }
  }

  async function get_events (events_drive) {
    if (!events_drive) return []
    try {
      await events_drive.ready()
      const files = await events_drive.list('/events')
      return read_and_sort_events(events_drive, files)
    } catch (err) {
      console.error('Error getting events:', err)
      return []
    }
  }

  /***************************************
  DEVICE MANAGEMENT
  ***************************************/

  async function get_paired_devices (events_drive_param) {
    const events = await get_events(events_drive_param)
    return build_paired_devices_list(events)
  }

  async function get_device_name (events_drive_param, metadata_writer_key) {
    const devices = await get_paired_devices(events_drive_param)
    const device = devices.find(d => d.metadata_writer === metadata_writer_key)
    return device ? device.name : null
  }

  async function remove_device (events_drive_param, device) {
    const state = get_state()
    if (!state.ds_manager) {
      console.error('Datastructure manager not initialized')
      return false
    }
    try {
      const structure_names = state.ds_manager.get_names()
      const removal_data = {}
      for (const name of structure_names) {
        const writer_key_name = `${name}_writer`
        const writer_key = device[writer_key_name]
        if (writer_key) {
          removal_data[writer_key_name] = writer_key
          try {
            await state.ds_manager.remove_writer(name, writer_key)
            console.log(`Removed writer from ${name}`)
          } catch (err) {
            console.warn(`Failed to remove writer from ${name}:`, err.message)
          }
        }
      }
      await log_event(events_drive_param, 'remove', removal_data)
      console.log('Device removed successfully')
      state.emitter.emit('update')
      return true
    } catch (err) {
      console.error('Error removing device:', err)
      return false
    }
  }

  /***************************************
  WRITER ACCESS MANAGEMENT
  ***************************************/

  // Universal writer management, Based on the APP_ID, we can setup writer requests.

  // Inviter Devide: Watch vault for writer requests from paired devices
  function start_writer_watcher (app_id) {
    const state = get_state()
    if (!state.vault_bee) return
    const watcher = state.vault_bee.watch({ gte: `writer_requests/${app_id}`, lt: `writer_requests/${app_id}0` })
    watch_writer_requests(watcher)
    async function watch_writer_requests (watcher) {
      for await (const _ of watcher) {
        await process_writer_requests()
      }
    }
    async function process_writer_requests () {
      const requests = await vault_get(`writer_requests/${app_id}`)
      if (!requests) return
      let processed_any = false
      for (const req of requests) {
        if (req.processed) continue
        processed_any = true
        await add_writers_from_request(app_id, req)
        req.processed = true
        req.processed_at = Date.now()
        await log_device_pairing(req)
      }
      if (processed_any) {
        await vault_put(`writer_requests/${app_id}`, requests)
        state.emitter.emit('update')
      }
    }
    async function log_device_pairing (req) {
      const device_keys = {}
      for (const [name, key] of Object.entries(req.writer_keys)) {
        device_keys[`${name}_writer`] = key
      }
      const events_drive = state.events_drive
      await log_event(events_drive, 'add', device_keys)
    }
  }

  async function add_writers_from_request (app_id, req) {
    const state = get_state()
    for (const [name, key] of Object.entries(req.writer_keys)) {
      try {
        if (name === 'app_audit') {
          const app_audit = state.app_audits.get(app_id)
          if (app_audit) await app_audit.add_writer(key)
        } else {
          await state.ds_manager.add_writer(name, key)
        }
        console.log(`[identity] Added writer to ${name}:`, key)
      } catch (err) {
        console.error(`[identity] Failed to add writer to ${name}:`, err.message)
      }
    }
  }

  // Pairing Device: Request writer access by submitting local writer keys to vault
  async function request_writer_access (app_id) {
    const state = get_state()
    if (!state.vault_bee) return
    const writer_keys = {}
    for (const name of state.ds_manager.get_names()) {
      const structure = state.ds_manager.get(name)
      const config = state.ds_manager.get_config(name)
      const key = get_local_writer_key(structure, config.type)
      if (key) writer_keys[name] = b4a.toString(key, 'hex')
    }
    // Include app_audit writer key
    const app_audit = state.app_audits.get(app_id)
    if (app_audit) {
      writer_keys.app_audit = b4a.toString(app_audit.base.local.key, 'hex')
    }
    const requests = await vault_get(`writer_requests/${app_id}`) || []
    requests.push({ writer_keys, requested_at: Date.now(), processed: false })
    await vault_put(`writer_requests/${app_id}`, requests)
    return writer_keys
  }

  // Pairing Device: Wait until Device A processes our writer access request
  async function wait_for_writer_access (app_id) {
    const state = get_state()
    const our_key = state.ds_manager.get('metadata')?.local?.key
    if (!state.vault_bee || !our_key) return false
    const our_hex = b4a.toString(our_key, 'hex')
    for await (const _ of state.vault_bee.watch({ gte: `writer_requests/${app_id}`, lt: `writer_requests/${app_id}0` })) {
      const reqs = await vault_get(`writer_requests/${app_id}`)
      if (reqs?.find(r => r.writer_keys?.metadata === our_hex && r.processed)) return true
    }
  }

  // Log bootstrap device (seed device) with all structure writer keys
  async function log_bootstrap_device (app_id) {
    const state = get_state()
    if (!state.ds_manager) return
    const device_keys = {}
    for (const name of state.ds_manager.get_names()) {
      const structure = state.ds_manager.get(name)
      const config = state.ds_manager.get_config(name)
      const writer_key = get_local_writer_key(structure, config.type)
      if (writer_key) {
        device_keys[`${name}_writer`] = b4a.toString(writer_key, 'hex')
      }
    }
    const events_drive = state.events_drive
    const existing_devices = await get_paired_devices(events_drive)
    const device_exists = existing_devices.some(d => d.metadata_writer === device_keys.metadata_writer)
    if (!device_exists) {
      await log_event(events_drive, 'add', device_keys)
    }
  }

  /***************************************
  RAW DATA INSPECTION
  ***************************************/

  async function get_raw_data (structure_name) {
    const state = get_state()
    if (!state.ds_manager) return 'Datastructure manager not initialized'
    const structure = state.ds_manager.get(structure_name)
    if (!structure) return `Structure '${structure_name}' not found`
    const config = state.ds_manager.get_config(structure_name)
    return extract_raw_data(structure, config, structure_name)
  }
}

/***************************************
GENERAL HELPER FUNCTIONS
***************************************/

/***************************************
MAKE EMITTER
***************************************/
function make_emitter (state = {}) {
  return { on, off, emit }
  function on (type, callback) { (state[type] = state[type] || []).push(callback) }
  function off (type, callback) { (state[type] = state[type] || [])[state[type].indexOf(callback)] = undefined }
  function emit (type, data) {
    function handle_callback (f) {
      return f && f(data)
    }
    return (state[type] = state[type] || []).map(handle_callback)
  }
}

/***************************************
PARSE VAULT INVITE
***************************************/
function parse_vault_invite (invite_code) {
  let invite_data
  try {
    invite_data = JSON.parse(b4a.toString(b4a.from(invite_code, 'base64')))
  } catch (err) {
    throw new Error(`Invalid invite code: ${err.message}`)
  }
  if (!invite_data.vault_only) {
    throw new Error('Unsupported invite format')
  }
  return invite_data
}

/***************************************
READ AND SORT EVENTS
***************************************/
async function read_and_sort_events (events_drive, files) {
  const events = []
  for (const file of files) {
    try {
      const content = await events_drive.get(file)
      if (content) {
        events.push(JSON.parse(b4a.toString(content)))
      }
    } catch (err) {
      console.error('Error reading event file:', file, err)
    }
  }
  return events.sort((a, b) => a.meta.time - b.meta.time)
}

/***************************************
BUILD PAIRED DEVICES LIST
***************************************/
function build_paired_devices_list (events) {
  const devices_map = new Map()
  let device_counter = 0
  events.forEach(event => {
    const device_id = event.data.metadata_writer
    if (event.type === 'add') {
      devices_map.set(device_id, {
        name: `Device ${++device_counter}`,
        timestamp: event.meta.time,
        added_date: new Date(event.meta.time).toLocaleString(),
        ...Object.fromEntries(
          Object.entries(event.data).filter(([key]) => key.endsWith('_writer'))
        )
      })
    } else if (event.type === 'remove') {
      devices_map.delete(device_id)
    }
  })
  return Array.from(devices_map.values())
}

/***************************************
GET LOCAL WRITER KEY
***************************************/
function get_local_writer_key (structure, type) {
  if (type === 'autobase') return structure.local?.key
  if (type === 'autodrive' || type === 'auditcore') return structure.base?.local?.key
}

/***************************************
EXTRACT RAW DATA
***************************************/
async function extract_raw_data (structure, config, structure_name) {
  try {
    await structure.ready()
    if (config.type === 'autobase') return extract_indexed(structure.view, structure_name, 'Autobase', true)
    if (config.type === 'auditcore') return extract_indexed(structure, structure_name, 'Auditcore', false)
    if (config.type === 'autodrive') return extract_files(structure, structure_name)
    return `Unknown structure type: ${config.type}`
  } catch (err) {
    return `Error reading ${structure_name}: ${err.message}`
  }
}

async function extract_indexed (source, name, type, parse) {
  if (source.length === 0) return `${type} '${name}' is empty`
  const entries = []
  for (let i = 0; i < source.length; i++) {
    try {
      const data = parse ? JSON.parse(await source.get(i)) : await source.get(i)
      entries.push(`[${i}] ${JSON.stringify(data, null, 2)}`)
    } catch (err) {
      entries.push(`[${i}] Error: ${err.message}`)
    }
  }
  return entries.join('\n\n')
}

async function extract_files (drive, name) {
  try {
    const list = await drive.list('/')
    if (list.length === 0) return `Autodrive '${name}' is empty`
    const files = []
    for (const file of list) {
      try {
        const content = await drive.get(file)
        files.push(`${file}:\n${content ? b4a.toString(content) : 'null'}`)
      } catch (err) {
        files.push(`${file}: Error: ${err.message}`)
      }
    }
    return files.join('\n\n---\n\n')
  } catch (err) {
    return `List error: ${err.message}`
  }
}
