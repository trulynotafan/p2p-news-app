const Autobase = require('autobase')
const Hyperdrive = require('hyperdrive')
const b4a = require('b4a')
const { EventEmitter } = require('events')
const IdentityKey = require('keet-identity-key')
const c = require('compact-encoding')

// Global storage for challenges
let _challenges = new Map()



// Invite encoder/decoder
const invite_encoder = {
  preencode(state, msg) {
    c.fixed32.preencode(state, b4a.from(msg.drive_bootstrap_key, 'hex'))
    c.fixed32.preencode(state, b4a.from(msg.bootstrap_device_key, 'hex'))
    c.string.preencode(state, msg.challenge)
  },
  encode(state, msg) {
    c.fixed32.encode(state, b4a.from(msg.drive_bootstrap_key, 'hex'))
    c.fixed32.encode(state, b4a.from(msg.bootstrap_device_key, 'hex'))
    c.string.encode(state, msg.challenge)
  },
  decode(state) {
    return {
      drive_bootstrap_key: c.fixed32.decode(state).toString('hex'),
      bootstrap_device_key: c.fixed32.decode(state).toString('hex'),
      challenge: c.string.decode(state)
    }
  }
}

function create_autodrive(store, bootstrap, opts = {}) {
  const emitter = new EventEmitter()
  const state = {
    store,
    drive: null,
    bootstrap,
    readers: new Set(),
    writers: new Set(),
    opts,
    base: null
  }

  // Autobase handlers
  function _open(store) {
    const drive_store = store.base.store.namespace('autodrive-' + store.base.version)
    const drive = new Hyperdrive(drive_store)
    return { drive }
  }

  async function _apply(nodes, view, base) {
    await view.drive.ready()
    const batch = view.drive.batch()
    for (const node of nodes) {
      const op = node.value
      if (!op) continue

      if (op.type === 'put') {
        const buffer = b4a.from(op.content, 'base64')
        await batch.put(op.path, buffer)
        emitter.emit('content-added', { path: op.path, content: buffer })
      } else if (op.type === 'del') {
        await batch.del(op.path)
      } else if (op.type === 'add_writer') {
        const key = b4a.from(op.key, 'hex')
        await base.addWriter(key, { indexer: op.is_indexer })
        state.writers.add(op.key)
        emitter.emit('writer-added', { key: op.key, is_indexer: op.is_indexer })
      } else if (op.type === 'add_reader') {
        state.readers.add(op.key)
        emitter.emit('reader-added', { key: op.key })
      } else if (op.type === 'remove_writer') {
        const key = b4a.from(op.key, 'hex')
        await base.removeWriter(key)
        state.writers.delete(op.key)
        emitter.emit('writer-removed', { key: op.key })
      } else if (op.type === 'remove_reader') {
        state.readers.delete(op.key)
        emitter.emit('reader-removed', { key: op.key })
      }
    }
    await batch.flush()
  }

  async function _close(view) {
    await view.drive.close()
  }

  state.base = new Autobase(store, bootstrap, {
    inputs: [store.get({ name: 'writer' })],
    valueEncoding: 'json',
    open: _open,
    apply: _apply,
    close: _close,
    ackInterval: opts.ack_interval || 5000
  })

  const api = {
    on: (event, listener) => emitter.on(event, listener),
    off: (event, listener) => emitter.off(event, listener),
    emit: (event, ...args) => emitter.emit(event, ...args),
    get base() { return state.base },
    async ready() {
      await state.base.ready()
      state.drive = state.base.view.drive
    },
    async init() {
      if (!state.bootstrap) return
    },
    async close() {
      await state.base.close()
    },
    async put(path, content) {
      await api.ready()
      await state.base.append({ type: 'put', path, content: b4a.toString(content, 'base64') })
    },
    async del(path) {
      await api.ready()
      await state.base.append({ type: 'del', path })
      await state.base.update()
    },
    async get(path, opts) {
      await api.ready()
      return state.drive.get(path, opts)
    },

    async list(folder = '/', opts = {}) {
      await api.ready();
      // List only immediate children (files and directories)
      const entries = [];
      for await (const entry of await state.drive.list(folder, { ...opts, recursive: false })) {
        entries.push(entry.key);
      }
      return entries;
    },
    replicate(isInitiator, options) {
      return state.base.replicate(isInitiator, options)
    },
    async download(folder = '/', opts) {
      if (typeof folder === 'object') return api.download(undefined, folder)
      const dls = []
      const entry = (!folder || folder.endsWith('/')) ? null : await state.drive.entry(folder)
      if (entry) {
        const b = entry.value.blob
        if (!b) return
        const blobs = await state.drive.getBlobs()
        await blobs.core.download({ start: b.blockOffset, length: b.blockLength }).downloaded()
        return
      }
      for await (const _ of state.drive.list(folder, opts)) {}
      for await (const entry of state.drive.list(folder, opts)) {
        const b = entry.value.blob
        if (!b) continue
        const blobs = await state.drive.getBlobs()
        dls.push(blobs.core.download({ start: b.block_offset, length: b.block_length }))
      }
      const proms = []
      for (const r of dls) proms.push(r.downloaded())
      await Promise.allSettled(proms)
    },
    async add_writer(key, opts = {}) {
      const key_str = typeof key === 'string' ? key : key.toString('hex')
      const is_indexer = opts.is_indexer === undefined ? true : !!opts.is_indexer
      await state.base.append({ type: 'add_writer', key: key_str, is_indexer })
      await state.base.update()
    },
    async add_reader(key) {
      const key_str = typeof key === 'string' ? key : key.toString('hex')
      await state.base.append({ type: 'add_reader', key: key_str })
      await state.base.update()
    },
    async remove_reader(key) {
      const key_str = typeof key === 'string' ? key : key.toString('hex')
      await state.base.append({ type: 'remove_reader', key: key_str })
      await state.base.update()
    },
    async remove_writer(key) {
      const key_str = typeof key === 'string' ? key : key.toString('hex')
      await state.base.append({ type: 'remove_writer', key: key_str })
      await state.base.update()
    },
    get_readers() { return Array.from(state.readers) },
    get_writers() { return Array.from(state.writers) },
    is_reader(key) {
      const key_str = typeof key === 'string' ? key : key.toString('hex')
      return state.readers.has(key_str)
    },
    is_writer(key) {
      const key_str = typeof key === 'string' ? key : key.toString('hex')
      return !!state.writers.has(key_str) || (state.base.writers && state.base.writers.some(w => w.key.toString('hex') === key_str)) || key_str === state.base.key.toString('hex')
    },
    async exists(path) {
      try {
        return !!(await state.drive.get(path))
      } catch {
        return false
      }
    },
    replicate(stream_or_initiator, opts = {}) {
      if (typeof stream_or_initiator === 'boolean') return state.store.replicate(stream_or_initiator, opts)
      const stream = stream_or_initiator
      return state.store.replicate(stream, opts)
    },

    async pair_with_proof(proof, device_public_key) {
      const proof_buf = Buffer.from(proof, 'hex')
      const auth = IdentityKey.verify(proof_buf, null)
      if (!auth) throw new Error('Invalid proof')
      if (!Buffer.from(auth.devicePublicKey).equals(device_public_key)) throw new Error('Proof not for this device')
      await state.base.append({ type: 'add_writer', key: device_public_key.toString('hex'), is_indexer: true })
      await state.base.update()
      emitter.emit('writer-added', { key: device_public_key.toString('hex') })
      return true
    }
  }
  return api
}

async function create_wildcard_invite(bootstrap_mnemonic, drive_bootstrap_key, bootstrap_device_key) {
  const challenge = Buffer.from(Date.now().toString()).toString('hex')
  const invite = { drive_bootstrap_key: drive_bootstrap_key.toString('hex'), bootstrap_device_key: bootstrap_device_key.toString('hex'), challenge }
  _challenges.set(challenge, bootstrap_mnemonic)
  return c.encode(invite_encoder, invite).toString('base64')
}

async function verify_challenge(challenge, device_public_key) {
  const mnemonic = _challenges.get(challenge)
  if (!mnemonic) return null
  const proof = await IdentityKey.bootstrap({ mnemonic }, device_public_key)
  _challenges.delete(challenge)
  return Buffer.from(proof).toString('hex')
}

// Static function to get local core (copied from Autobase to avoid full import) // i just copied it from easybase to send writer key before pairing. 
function getLocalCore(store, handlers, encryptionKey) {
  const messages = require('autobase/lib/messages')
  const opts = { ...handlers, compat: false, active: false, exclusive: true, valueEncoding: messages.OplogMessage, encryptionKey }
  return opts.keyPair ? store.get(opts) : store.get({ ...opts, name: 'local' })
}

module.exports = { create_autodrive, create_wildcard_invite, verify_challenge, invite_encoder, getLocalCore }
