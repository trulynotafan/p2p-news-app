const { create_autodrive } = require('../index.js')
const Corestore = require('corestore')
const RAM = require('random-access-memory')
const b4a = require('b4a')

async function main () {
  const results = []

  function record (name, passed, err) {
    results.push({ name, passed, err })
    if (!passed) console.error(`[FAILED] ${name}:`, err && err.message)
    else console.log(`[PASSED] ${name}`)
  }

  console.log('=========================================================================')
  console.log('                   AUTODRIVE COMPREHENSIVE TEST       ')
  console.log('=========================================================================')

  // === SETUP ===
  console.log('\n--- SETUP PHASE ---')
  console.log('initializing two drives and setting up replication...')

  const store_1 = new Corestore(RAM)
  const store_2 = new Corestore(RAM)

  const drive_1 = create_autodrive({ store: store_1, bootstrap: null })
  await drive_1.ready()
  console.log('drive 1 ready, key:', drive_1.base.key.toString('hex'))

  const drive_2 = create_autodrive({ store: store_2, bootstrap: drive_1.base.key })
  await drive_2.ready()
  console.log('drive 2 ready, key:', drive_2.base.key.toString('hex'))

  const s1 = drive_1.replicate(true)
  const s2 = drive_2.replicate(false)
  s1.pipe(s2).pipe(s1)
  console.log('replication streams connected successfully')

  // === EVENT HANDLING ===
  console.log('\n--- EVENT SETUP ---')
  console.log('configuring event listeners on drive 2...')

  const events = {
    content: null,
    writer_added: null,
    writer_removed: null
  }

  drive_2.on('content-added', (p) => {
    events.content = p
    const readable_content = { path: p.path, content: b4a.toString(p.content) }
    console.log('event: content-added ->', readable_content)
  })

  drive_2.on('writer-added', (w) => {
    events.writer_added = w
    console.log('event: writer-added ->', w)
  })

  drive_2.on('writer-removed', (w) => {
    events.writer_removed = w
    console.log('event: writer-removed ->', w)
  })

  // === FILE OPERATIONS ===
  console.log('\n--- FILE OPERATIONS ---')
  console.log('testing put, get, exists, list, del operations...')

  try {
    console.log('writing files to drive 1...')
    await drive_1.put('/folder/file.txt', b4a.from('hello'))
    await drive_1.put('/file.txt', b4a.from('world'))
    console.log('files written, waiting for replication...')
    await new Promise(resolve => setTimeout(resolve, 500))

    console.log('testing file retrieval from drive 2...')
    const file_content = await drive_2.get('/folder/file.txt')
    console.log('retrieved content:', b4a.toString(file_content))
    record('put/get', b4a.toString(file_content) === 'hello')

    console.log('testing file existence...')
    const file_exists = await drive_2.exists('/file.txt')
    console.log('file exists:', file_exists)
    record('exists (present)', file_exists === true)

    console.log('testing directory listing...')
    const file_list = await drive_2.list('/')
    console.log('directory contents:', file_list)
    const has_file = file_list.includes('/file.txt')
    const has_folder = file_list.includes('/folder/') || file_list.includes('/folder/file.txt')
    console.log('validation - file found:', has_file, 'folder found:', has_folder)
    const list_result = !!(has_file && has_folder)
    if (!list_result) console.error('list test failed, expected both file and folder')
    record('list', list_result)

    console.log('checking content-added event...')
    record('content-added event', events.content && events.content.path === '/file.txt')

    console.log('testing file deletion...')
    await drive_1.del('/file.txt')
    console.log('waiting for deletion to replicate...')
    await new Promise(resolve => setTimeout(resolve, 500))
    const exists_after_del = await drive_2.exists('/file.txt')
    console.log('file exists after deletion:', exists_after_del)
    record('del/exists (deleted)', exists_after_del === false)
  } catch (err) {
    console.error('file operations error:', err.message)
    record('FILES block', false, err)
  }

  // === USER MANAGEMENT ===
  console.log('\n--- USER MANAGEMENT ---')
  console.log('testing reader/writer permissions...')

  try {
    console.log('adding reader permission...')
    const reader_key = b4a.from('a'.repeat(64), 'hex')
    await drive_1.add_reader(reader_key)

    console.log('adding writer permission for drive 2...')
    const drive_2_key = drive_2.base.local.key
    await drive_1.add_writer(drive_2_key)
    console.log('waiting for permissions to propagate...')
    await new Promise(resolve => setTimeout(resolve, 500))

    console.log('testing permission checks...')
    const is_reader = drive_2.is_reader(reader_key)
    console.log('reader check result:', is_reader)
    record('is_reader', is_reader)

    const readers = drive_2.get_readers()
    const reader_in_list = readers.includes(reader_key.toString('hex'))
    console.log('reader in list:', reader_in_list)
    record('get_readers', reader_in_list)

    const is_writer = drive_1.is_writer(drive_2_key)
    console.log('writer check result:', is_writer)
    record('is_writer', is_writer)

    const writer_event_ok = events.writer_added && events.writer_added.key === drive_2_key.toString('hex')
    record('writer-added event', writer_event_ok)

    console.log('testing write from new writer...')
    await drive_2.put('/from-drive2.txt', b4a.from('it works'))
    await new Promise(resolve => setTimeout(resolve, 500))
    const content_from_drive_2 = await drive_1.get('/from-drive2.txt')
    console.log('content written by drive 2:', b4a.toString(content_from_drive_2))
    record('write from new writer', b4a.toString(content_from_drive_2) === 'it works')

    console.log('removing writer permission...')
    try {
      await drive_1.remove_writer(drive_2_key)
      console.log('writer removed successfully')
    } catch (err) {
      console.error('error removing writer:', err.message)
      throw err
    }

    await new Promise(resolve => setTimeout(resolve, 500))
    const is_writer_after = drive_1.is_writer(drive_2_key)
    console.log('writer status after removal:', is_writer_after)
    record('remove_writer', is_writer_after === false)

    const writer_removed_event_ok = events.writer_removed && events.writer_removed.key === drive_2_key.toString('hex')
    record('writer-removed event', writer_removed_event_ok)
  } catch (err) {
    console.error('user management error:', err.message)
    record('USERS block', false, err)
  }

  // === DOWNLOAD TESTING ===
  console.log('\n--- DOWNLOAD TEST ---')
  console.log('testing download functionality...')

  try {
    console.log('re-adding files for download test...')
    await drive_1.put('/folder/file.txt', Buffer.from('hello'))
    await drive_1.put('/file.txt', Buffer.from('world'))
    await new Promise(resolve => setTimeout(resolve, 3000))

    console.log('creating drive 3 for download test...')
    const store_3 = new Corestore(RAM)
    const drive_3 = create_autodrive({ store: store_3, bootstrap: drive_1.base.key })
    await drive_3.ready()
    console.log('drive 3 ready, setting up replication...')

    const s3 = drive_3.base.replicate(true, { live: true })
    const s1b = drive_1.base.replicate(false, { live: true })
    s3.pipe(s1b).pipe(s3)

    console.log('checking pre-download state...')
    const exists_before_1 = await drive_3.exists('/folder/file.txt')
    const exists_before_2 = await drive_3.exists('/file.txt')
    console.log('before download - folder file:', exists_before_1, 'root file:', exists_before_2)

    console.log('triggering download...')
    await drive_3.download('/')

    console.log('waiting for download completion...')
    let all_files_downloaded = false
    const max_retries = 15

    for (let i = 0; i < max_retries; i++) {
      await new Promise(resolve => setTimeout(resolve, 1000))
      console.log(`download check ${i + 1}/${max_retries}...`)

      try {
        const content_1 = await drive_3.get('/folder/file.txt')
        const content_2 = await drive_3.get('/file.txt')

        if (content_1 && content_2) {
          console.log('all files downloaded successfully!')
          const content_1_str = b4a.toString(content_1)
          const content_2_str = b4a.toString(content_2)
          console.log('verification - folder file:', content_1_str, 'root file:', content_2_str)
          all_files_downloaded = true
          break
        }
        console.log('files not ready yet, retrying...')
      } catch (err) {
        console.log(`attempt ${i + 1} failed:`, err.message)
      }
    }

    record('download', all_files_downloaded)

    console.log('cleaning up download test...')
    s3.destroy()
    s1b.destroy()
    await drive_3.close()
  } catch (err) {
    console.error('download test error:', err.message)
    record('download', false)
  }

  // === CLEANUP ===
  console.log('\n--- CLEANUP ---')
  console.log('closing streams and drives...')

  const closing = new Promise(resolve => {
    let open = 2
    s1.on('close', () => --open || resolve())
    s2.on('close', () => --open || resolve())
  })

  s1.destroy()
  s2.destroy()
  await closing
  await drive_1.close()
  await drive_2.close()

  // === RESULTS ===
  console.log('\n=========================================================================')
  console.log('                            TEST RESULTS')
  console.log('=========================================================================')

  for (const r of results) {
    const status = r.passed ? 'PASS' : 'FAIL'
    const icon = r.passed ? '[+]' : '[X]'
    console.log(`${icon} ${status} | ${r.name}`)
  }

  const passed = results.filter(r => r.passed).length
  const failed = results.filter(r => !r.passed).length

  console.log('=========================================================================')
  console.log(`total: ${results.length} | passed: ${passed} | failed: ${failed}`)
  console.log('=========================================================================')

  if (failed > 0) {
    console.log('some tests failed, exiting with error')
    process.exit(1)
  } else {
    console.log('all tests passed!')
    process.exit(0)
  }
}

main().catch(err => {
  console.error('\n=========================================================================')
  console.error('                              TEST CRASHED')
  console.error('=========================================================================')
  console.error('error:', err.message)
  console.error('stack:', err.stack)
  process.exit(1)
})
