// Simple P2P blog helper
const b4a = require('b4a')
const { create_autodrive } = require('../../autodrive')
const EventEmitter = require('events')

let store, blog_core, drive
const emitter = new EventEmitter()
const connected_peers = new Map()
const peer_drives = new Map()

// Local storage helpers
function get_subscribed_peers() {
  try { return JSON.parse(localStorage.getItem('subscribed_peers') || '[]') } catch { return [] }
}
function add_subscribed_peer(key) {
  const peers = get_subscribed_peers()
  if (!peers.includes(key)) {
    peers.push(key)
    localStorage.setItem('subscribed_peers', JSON.stringify(peers))
  }
}
function remove_subscribed_peer(key) {
  const peers = get_subscribed_peers().filter(k => k !== key)
  localStorage.setItem('subscribed_peers', JSON.stringify(peers))
}

// Initialize your blog
async function init_blog(store_instance, username) {
  store = store_instance
  blog_core = store.get({ name: 'blog-feed' })
  drive = create_autodrive(store, blog_core.key)
  await blog_core.ready()
  await drive.ready()
  
  if (blog_core.length === 0) {
    await blog_core.append(JSON.stringify({
      type: 'blog-init',
      drive_key: b4a.toString(drive.base.key, 'hex'),
      title: `${username}'s Blog`,
      username
    }))
  }
  
  setup_event_handlers()
  emitter.emit('update')
}

// Setup common event handlers
function setup_event_handlers() {
  blog_core.on('append', () => emitter.emit('update'))
  store.on('feed', () => {
    console.log('PEER POSTED NEW CONTENT')
    emitter.emit('update')
  })
  
  store.on('blog-discovered', async (core) => {
    const key = b4a.toString(core.key, 'hex')
    if (key === b4a.toString(blog_core.key, 'hex')) return
    try {
      await core.ready()
      if (core.length === 0) return
      const init_block = JSON.parse(b4a.toString(await core.get(0)))
      if (init_block.type === 'blog-init' && !get_subscribed_peers().includes(key)) {
        connected_peers.set(key, { ...init_block, key })
        emitter.emit('update')
      }
    } catch (err) {
      // Silent error handling
    }
  })
}

// Create a post
async function create_post(title, content) {
  const filepath = `/posts/${Date.now()}.txt`
  await drive.put(filepath, b4a.from(`${title}\n\n${content}`))
  await blog_core.append(JSON.stringify({
    type: 'blog-post',
    filepath,
    created: Date.now()
  }))
  emitter.emit('update')
}

// Subscribe to peer
async function subscribe(key) {
  if (get_subscribed_peers().includes(key)) return true
  try {
    const peer_core = store.get(b4a.from(key, 'hex'))
    await peer_core.ready()
    if (peer_core.length === 0) await peer_core.update({ wait: true })
    const init_block = JSON.parse(b4a.toString(await peer_core.get(0)))
    // Create peer drive
    const peer_store = store.namespace(`peer-${init_block.drive_key.slice(0, 16)}`)
    const peer_drive = create_autodrive(peer_store, b4a.from(init_block.drive_key, 'hex'))
    // Store for later use
    peer_drives.set(key, peer_drive)
    add_subscribed_peer(key)
    // Remove from discovered peers since they're now subscribed
    connected_peers.delete(key)
    return true
  } catch (err) {
    return false
  }
}

// Get your posts
async function get_my_posts() {
  const posts = []
  for (let i = 1; i < blog_core.length; i++) {
    try {
      const entry = JSON.parse(b4a.toString(await blog_core.get(i)))
      if (entry.type === 'blog-post') {
        const content = await drive.get(entry.filepath)
        if (content) {
          const contentStr = b4a.toString(content)
          const lines = contentStr.split('\n')
          posts.push({
            ...entry,
            title: lines[0],
            content: lines.slice(2).join('\n') // Skip title and empty line
          })
        }
      }
    } catch (err) {
      // Silent error handling
    }
  }
  return posts.reverse()
}

// Get peer blogs
async function get_peer_blogs() {
  const blogs = new Map()
  const subscribed_peers = get_subscribed_peers()
  for (const key of subscribed_peers) {
    try {
      const peer_core = store.get(b4a.from(key, 'hex'))
      await peer_core.ready()
      if (peer_core.length === 0) continue
      const init_block = JSON.parse(b4a.toString(await peer_core.get(0)))
      let peer_drive = peer_drives.get(key)
      // Create peer drive if not cached
      if (!peer_drive) {
        const peer_store = store.namespace(`peer-${init_block.drive_key.slice(0, 16)}`)
        peer_drive = create_autodrive(peer_store, b4a.from(init_block.drive_key, 'hex'))
        peer_drives.set(key, peer_drive)
      }
      await peer_drive.ready()
      const posts = []
      for (let i = 1; i < peer_core.length; i++) {
        try {
          const entry = JSON.parse(b4a.toString(await peer_core.get(i)))
          if (entry.type === 'blog-post') {
            // Read from local replicated storage, not re-download
            const content = await peer_drive.get(entry.filepath)
            if (content) {
              const contentStr = b4a.toString(content)
              const lines = contentStr.split('\n')
              posts.push({
                title: lines[0] || 'Untitled',
                filepath: entry.filepath,
                created: entry.created,
                content: lines.length > 2 ? lines.slice(2).join('\n') : ''
              })
            } else {
              posts.push({
                title: 'Untitled',
                filepath: entry.filepath,
                created: entry.created,
                content: ''
              })
            }
          }
        } catch (err) {
          // Silent error handling
        }
      }
      blogs.set(key, {
        key,
        posts: posts.reverse(),
        username: init_block.username,
        title: init_block.title
      })
    } catch (err) {
      // Silent error handling
    }
  }
  return blogs
}

module.exports = {
  init_blog,
  create_post,
  subscribe,
  get_my_posts,
  get_peer_blogs,
  get_discovered_blogs: () => connected_peers,
  get_my_core_key: () => blog_core?.key,
  get_drive: () => drive,
  on_update: cb => emitter.on('update', cb),
  unsubscribe: key => { remove_subscribed_peer(key); peer_drives.delete(key); emitter.emit('update') }
}