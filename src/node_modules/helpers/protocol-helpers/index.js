const c = require('compact-encoding')
const b4a = require('b4a')

function identity_exchange_protocol (handlers, init_fn, options = {}) {
  const { peer_mode = 'unknown', label = '[peer]', identity_info, peer_info } = options

  return function (mux) {
    let has_received_key = false

    const channel = mux.createChannel({
      protocol: 'identity-exchange',
      onopen: () => {
        console.log(label, 'Identity channel opened')

        const message = channel.addMessage({
          encoding: c.json,
          onmessage: async (msg) => {
            try {
              // Handle protocol message
              if (msg.type === 'protocol') {
                if (handlers.on_protocol) {
                  await handlers.on_protocol(msg, m => message.send(m), peer_mode)
                }
              }

              // Handle feedkey message
              if (msg.type === 'feedkey' && !has_received_key) {
                has_received_key = true
                const key_buffer = b4a.from(msg.data, 'hex')

                if (!key_buffer || key_buffer.length !== 32) {
                  console.error('Invalid feed key:', msg.data)

                  return
                }

                if (handlers.on_feedkey) {
                  await handlers.on_feedkey({
                    key_buffer,
                    hex_key: key_buffer.toString('hex'),
                    message: msg
                  }, m => message.send(m))
                }
              }

              // Handle autobase key request
              if (msg.type === 'autobase_key_request') {
                if (handlers.on_autobase_key_request) {
                  await handlers.on_autobase_key_request(msg.data, m => message.send(m))
                }
              }

              // Handle autobase key response
              if (msg.type === 'autobase_key_response') {
                if (handlers.on_autobase_key_response) {
                  await handlers.on_autobase_key_response(msg.data, m => message.send(m))
                }
              }

              // Handle writer request
              if (msg.type === 'writer_request') {
                if (handlers.on_writer_request) {
                  await handlers.on_writer_request(msg.data, m => message.send(m))
                }
              }

              // Handle writer added confirmation
              if (msg.type === 'writer_added') {
                if (handlers.on_writer_added) {
                  await handlers.on_writer_added(msg.data, m => message.send(m))
                }
              }
            } catch (err) {
              console.error(label, 'Error handling message:', err)
            }
          }
        })

        if (init_fn) init_fn(m => message.send(m))
      }
    })

    return channel
  }
}

module.exports = { identity_exchange_protocol }
