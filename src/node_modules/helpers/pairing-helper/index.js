const b4a = require('b4a')
const BlindPairing = require('blind-pairing')
const extend = require('@geut/sodium-javascript-plus/extend')
const sodium = extend(require('sodium-universal'))

let current_member = null
let current_candidate = null

// Create invite for sharing drive access
async function create_invite (drive_key, autobase_key, profile_drive_key) {
  console.log('Creating invite code...')
  const invite = BlindPairing.createInvite(drive_key)
  const invite_code = b4a.toString(invite.invite, 'base64')
  console.log('Invite code created successfully')
  return { invite_code, invite, autobase_key, profile_drive_key }
}

// Setup member to handle join requests
async function setup_member (options) {
  const { drive, blog_autobase, profile_drive, swarm, invite } = options
  const blind_pairing = new BlindPairing(swarm)
  await blind_pairing.ready()

  async function handle_pairing_request (request) {
    try {
      console.log('Pairing request received')
      await request.open(invite.publicKey)
      console.log('Pairing request opened')

      const user_data = request.userData

      // Split the concatenated keys (96 bytes total: 32 + 32 + 32)
      const metadata_writer_key = user_data.slice(0, 32)
      const drive_writer_key = user_data.slice(32, 64)
      const profile_writer_key = user_data.slice(64, 96)

      const metadata_writer_hex = b4a.toString(metadata_writer_key, 'hex')
      await blog_autobase.append({ type: 'addWriter', data: { key: metadata_writer_hex } })
      await blog_autobase.update()

      const drive_writer_hex = b4a.toString(drive_writer_key, 'hex')
      await drive.add_writer(drive_writer_hex)

      const profile_writer_hex = b4a.toString(profile_writer_key, 'hex')
      await profile_drive.add_writer(profile_writer_hex)

      console.log('Added as writer in the autobase, autodrive, and profile autodrive')

      request.confirm({
        key: drive.base.key,
        encryptionKey: blog_autobase.key
      })

      console.log('Device paired successfully')
    } catch (error) {
      console.error('Pairing error:', error.message)
    }
  }

  current_member = blind_pairing.addMember({
    discoveryKey: drive.base.discoveryKey,
    onadd: handle_pairing_request
  })

  await current_member.ready()
  current_member.announce()
  return current_member
}

// Join existing drive using invite
async function join_with_invite (options) {
  const { invite_code, swarm, store } = options
  const blind_pairing = new BlindPairing(swarm)
  await blind_pairing.ready()

  const invite_buffer = b4a.from(invite_code, 'base64')

  const metadata_store = store.namespace('blog-metadata')
  const drive_store = store.namespace('blog-files')

  const { getLocalCore } = require('../../autodrive')

  // Generate writer keys for metadata, drive, and profile
  const profile_store = store.namespace('blog-profile')
  const metadata_core = getLocalCore({ store: metadata_store })
  const drive_core = getLocalCore({ store: drive_store })
  const profile_core = getLocalCore({ store: profile_store })

  await Promise.all([metadata_core.ready(), drive_core.ready(), profile_core.ready()])

  const metadata_writer_key = metadata_core.key
  const drive_writer_key = drive_core.key
  const profile_writer_key = profile_core.key

  await Promise.all([metadata_core.close(), drive_core.close(), profile_core.close()])

  const user_data = b4a.concat([metadata_writer_key, drive_writer_key, profile_writer_key]) // Send all three keys

  console.log('Joining pairing network...')

  return new Promise((resolve, reject) => {
    async function handle_candidate_add (result) {
      try {
        console.log('Successfully joined network')
        resolve({
          drive_key: result.key,
          autobase_key: result.encryptionKey
        })
      } catch (error) {
        console.error('Join error:', error.message)
        reject(error)
      }
    }

    function handle_candidate_ready_error (error) {
      reject(error)
    }

    current_candidate = blind_pairing.addCandidate({
      invite: invite_buffer,
      userData: user_data,
      onadd: handle_candidate_add
    })

    current_candidate.ready().catch(handle_candidate_ready_error)
  })
}

module.exports = {
  create_invite,
  setup_member,
  join_with_invite
}
