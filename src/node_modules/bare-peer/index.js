const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const process = require('bare-process')
const protomux = require('protomux')
const { create_mnemonic_keypair, save, load } = require('../helpers/crypto-helpers/index.js')
const { identity_exchange_protocol } = require('../helpers/protocol-helpers/index.js')
const blog_helper = require('../helpers/blog-helpers/index.js')
const fs = require('bare-fs')
const path = require('bare-path')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

// file-based subscription management
const SUB_FILE = path.join(process.cwd(), 'subscribed_peers.json')
const file_subscription = {
  get () {
    try { return JSON.parse(fs.readFileSync(SUB_FILE, 'utf8')) } catch { return [] }
  },
  add (key) {
    const arr = this.get()
    if (!arr.includes(key)) arr.push(key)
    fs.writeFileSync(SUB_FILE, JSON.stringify(arr))
  },
  remove (key) {
    function filter_key (k) {
      return k !== key
    }
    const arr = this.get().filter(filter_key)
    fs.writeFileSync(SUB_FILE, JSON.stringify(arr))
  }
}
blog_helper.set_subscription_store(file_subscription)

async function start_native_peer (options = {}) {
  const name = options.name || `native-peer-${process.pid}`
  const label = `\x1b[${process.pid % 2 ? 31 : 34}m[peer-${name}]\x1b[0m`

  console.log(label, 'start')

  const seedphrase = await load(name)
  let mnemonic_data

  if (seedphrase) {
    console.log(label, 'Loaded existing seedphrase')
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise',
      mnemonic: seedphrase
    })
  } else {
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise'
    })
    await save(mnemonic_data.mnemonic, name)
    console.log(label, 'Generated and saved new mnemonic')
  }

  console.log(label, 'Generated mnemonic:', mnemonic_data.mnemonic)
  console.log(label, 'Peer key:', mnemonic_data.keypair.publicKey.toString('hex'))

  const store = new Corestore(`./storage-${name}`)
  await blog_helper.init_blog({ store_instance: store, username: name })
  const blog_core = store.get({ name: 'blog-feed' })
  await blog_core.ready()
  console.log(label, 'âœ… Blog system ready')

  const swarm = new Hyperswarm({ key_pair: mnemonic_data.keypair })

  swarm.on('connection', handle_swarm_connection)
  console.log(label, 'Joining swarm')
  swarm.join(topic, { server: true, client: true })
  swarm.flush()
  console.log('Swarm Joined, looking for peers')

  async function handle_swarm_connection (socket, info) {
    const peer_id = info.publicKey.toString('hex')

    function handle_socket_close () {
      console.log(label, `Peer disconnected [${peer_id.slice(0, 8)}]`)
    }

    function handle_socket_error (err) {
      if (!err.message?.includes('Duplicate connection')) {
        console.log(label, `connection error [${peer_id.slice(0, 8)}]:`, err.message)
      }
    }

    socket.on('close', handle_socket_close)
    socket.on('error', handle_socket_error)

    const mux = new protomux(socket)

    const handlers = {
      on_protocol: async (message, send) => {
        if (message.data && message.data.name) {
          console.log(label, `Discovered peer: ${message.data.name} (${message.data.mode})`)
        }
      },
      on_feedkey: async ({ key_buffer }, send) => {
        try {
          const hex_key = b4a.toString(key_buffer, 'hex')
          console.log(label, `Received feed key from [${peer_id.slice(0, 8)}]: ${hex_key.slice(0, 8)}`)
          // Let blog_helper handle discovery and subscription
          store.emit('core', store.get(key_buffer))
        } catch (err) {
          console.error(label, `Error handling peer core [${peer_id.slice(0, 8)}]:`, err)
        }
      }
    }

    function handle_protocol_init (send) {
      try {
        console.log(label, `Sending identity to [${peer_id.slice(0, 8)}]`)
        send({
          type: 'protocol',
          data: {
            name: name,
            mode: 'native',
            device_public_key: mnemonic_data.keypair.publicKey.toString('hex')
          }
        })
        send({
          type: 'feedkey',
          data: blog_core.key.toString('hex')
        })
        console.log(label, `Identity exchanged with [${peer_id.slice(0, 8)}]`)
      } catch (err) {
        console.error(label, `Error in identity exchange [${peer_id.slice(0, 8)}]:`, err)
      }
    }

    const setup_protocol = identity_exchange_protocol(handlers, handle_protocol_init, {
      peer_mode: 'native',
      label
    })

    const identity_channel = setup_protocol(mux)
    identity_channel.open()

    store.replicate(socket)
  }

  return {
    blog_helper,
    store,
    swarm,
    blog_core,
    subscribe: handle_peer_subscription
  }

  async function handle_peer_subscription (peer_key) {
    return await blog_helper.subscribe(peer_key)
  }
}

module.exports = {
  start: start_native_peer
}
