// using the local-storgae-shim (read it for more details)
require('../helpers/local-storage-shim')

const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const process = require('bare-process')
const protomux = require('protomux')
const { create_mnemonic_keypair, save, load } = require('../helpers/crypto-helpers/index.js')
const { identity_exchange_protocol } = require('../helpers/protocol-helpers/index.js')
const blog_helper = require('../helpers/blog-helpers/index.js')
const identity_helper = require('../helpers/identity-helper/index.js')
const pairing_helper = require('../helpers/pairing-helper/index.js')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

async function start_native_peer (options = {}) {
  const name = options.name || `native-peer-${process.pid}`
  const label = `\x1b[${process.pid % 2 ? 31 : 34}m[peer-${name}]\x1b[0m`

  console.log(label, 'start')

  const seedphrase = await load(name)
  let mnemonic_data

  if (seedphrase) {
    console.log(label, 'Loaded existing seedphrase')
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise',
      mnemonic: seedphrase
    })
  } else {
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise'
    })
    await save(mnemonic_data.mnemonic, name)
    console.log(label, 'Generated and saved new mnemonic')
  }

  console.log(label, 'Generated mnemonic:', mnemonic_data.mnemonic)
  console.log(label, 'Peer key:', mnemonic_data.keypair.publicKey.toString('hex'))

  const store = new Corestore(`./storage-${name}`)
  store.swarm = null // Will be set after swarm creation

  // Skip blog initialization if pairing mode (will be initialized after pairing)
  if (!options.pair_mode) {
    await blog_helper.init_blog({ store_instance: store, username: name })
    console.log(label, 'Blog system ready')
  } else {
    console.log(label, 'Skipping blog init (pairing mode)')
  }

  const swarm = new Hyperswarm({ key_pair: mnemonic_data.keypair })
  store.swarm = swarm

  // Set up connection handler BEFORE joining swarm
  async function handle_swarm_connection (socket, info) {
    const peer_id = info.publicKey.toString('hex')

    function handle_socket_close () {
      console.log(label, `Peer disconnected [${peer_id.slice(0, 8)}]`)
    }

    function handle_socket_error (err) {
      if (!err.message?.includes('Duplicate connection')) {
        console.log(label, `connection error [${peer_id.slice(0, 8)}]:`, err.message)
      }
    }

    socket.on('close', handle_socket_close)
    socket.on('error', handle_socket_error)

    const mux = new protomux(socket)

    const handlers = {
      on_protocol: async (message, send) => {
        if (message.data && message.data.name) {
          console.log(label, `Discovered peer: ${message.data.name} (${message.data.mode})`)
        }
      },
      on_feedkey: async ({ key_buffer }, send) => {
        try {
          const hex_key = b4a.toString(key_buffer, 'hex')
          console.log(label, `Received autobase key from [${peer_id.slice(0, 8)}]: ${hex_key.slice(0, 8)}`)

          // Emit peer-autobase-key event for blog_helper to handle
          store.emit('peer-autobase-key', { key: hex_key, key_buffer })
        } catch (err) {
          console.error(label, `Error handling peer autobase [${peer_id.slice(0, 8)}]:`, err)
        }
      },
      on_autobase_key_request: async (message, send) => {
        console.log(label, `Received autobase key request from [${peer_id.slice(0, 8)}]`)
        const autobase_key = blog_helper.get_autobase_key()
        if (autobase_key) {
          send({ type: 'autobase_key_response', data: autobase_key })
        }
      },
      on_autobase_key_response: async (message, send) => {
        console.log(label, `Received autobase key response from [${peer_id.slice(0, 8)}]`)
        if (message.data) {
          const key_buffer = b4a.from(message.data, 'hex')
          store.emit('peer-autobase-key', { key: message.data, key_buffer })
        }
      },
      on_writer_request: async (message, send) => {
        console.log(label, `Received writer request from [${peer_id.slice(0, 8)}]`)
        // Pairing helper will handle this
      },
      on_writer_confirm: async (message, send) => {
        console.log(label, `Received writer confirmation from [${peer_id.slice(0, 8)}]`)
        // Pairing helper will handle this
      }
    }

    function handle_protocol_init (send) {
      try {
        console.log(label, `Sending identity to [${peer_id.slice(0, 8)}]`)
        send({
          type: 'protocol',
          data: {
            name: name,
            mode: 'native',
            device_public_key: mnemonic_data.keypair.publicKey.toString('hex')
          }
        })

        const autobase_key = blog_helper.get_autobase_key()
        if (autobase_key) {
          send({
            type: 'feedkey',
            data: autobase_key
          })
        }

        console.log(label, `Identity exchanged with [${peer_id.slice(0, 8)}]`)
      } catch (err) {
        console.error(label, `Error in identity exchange [${peer_id.slice(0, 8)}]:`, err)
      }
    }

    const setup_protocol = identity_exchange_protocol(handlers, handle_protocol_init, {
      peer_mode: 'native',
      label
    })

    const identity_channel = setup_protocol(mux)
    identity_channel.open()

    // Replicate the entire store (includes all namespaces)
    store.replicate(socket)
  }

  // Register connection handler and join swarm
  swarm.on('connection', handle_swarm_connection)
  console.log(label, 'Joining swarm...')
  const discovery = swarm.join(topic, { server: true, client: true })

  // Store the flush promise for pairing
  const flush_promise = discovery.flushed()
    .then(() => console.log(label, 'Swarm joined and flushed'))
    .catch(err => console.warn(label, 'Flush warning:', err.message))

  console.log(label, 'Ready - discovering peers in background')

  return {
    blog_helper,
    identity_helper,
    pairing_helper,
    store,
    swarm,
    flush_promise,
    subscribe: handle_peer_subscription,
    create_invite: handle_create_invite,
    join_with_invite: handle_join_with_invite
  }

  async function handle_peer_subscription (peer_key) {
    return await blog_helper.subscribe(peer_key)
  }

  async function handle_create_invite () {
    try {
      const invite_code = await blog_helper.create_invite(swarm)
      console.log(label, 'Invite created:', invite_code)
      console.log(label, 'Keep this terminal open while others join')
      return invite_code
    } catch (err) {
      console.error(label, 'Error creating invite:', err)
      throw err
    }
  }

  async function handle_join_with_invite (invite_code) {
    try {
      console.log(label, 'Joining with invite code...')

      // Get keys from pairing
      const result = await pairing_helper.join_with_invite({ invite_code, swarm, store })
      console.log(label, 'Pairing successful')

      // Reinitialize blog with shared keys (this will replace the local blog)
      await blog_helper.init_blog({
        store_instance: store,
        username: name,
        drive_key: result.drive_key,
        autobase_key: result.autobase_key
      })

      // Wait for blog-init block to replicate
      const autobase = blog_helper.get_autobase()

      if (autobase.view.length === 0) {
        await new Promise((resolve) => {
          function handle_update () {
            if (autobase.view.length > 0) {
              autobase.removeListener('update', handle_update)
              resolve()
            }
          }
          autobase.on('update', handle_update)
        })
      }

      // Get username from the blog init block
      const username = await blog_helper.get_blog_username()
      console.log(label, 'Joined blog:', username)

      // Setup profile and events drives
      const b4a = require('b4a')
      const { create_autodrive } = require('../autodrive')

      // Helper to setup secondary drives
      async function setup_secondary_drive (type, getter, setter, namespace) {
        let drive_key = await getter()

        if (!drive_key) {
          drive_key = await new Promise((resolve) => {
            async function handle_update () {
              const key = await getter()
              if (key) resolve(key)
            }
            blog_helper.on_update(handle_update)
          })
        }

        if (drive_key) {
          const drive_store = store.namespace(namespace)
          const drive = create_autodrive({ store: drive_store, bootstrap: b4a.from(drive_key, 'hex') })
          await drive.ready()
          await drive.base.update()
          await drive.download('/')
          setter(drive, drive_store)
        }
      }

      await setup_secondary_drive('profile', blog_helper.get_blog_profile_drive_key, blog_helper.set_profile_drive, 'blog-profile')
      await setup_secondary_drive('events', blog_helper.get_blog_events_drive_key, blog_helper.set_events_drive, 'blog-events')

      console.log(label, 'Successfully paired!')
      return true
    } catch (err) {
      console.error(label, 'Error joining with invite:', err)
      return false
    }
  }
}

module.exports = {
  start: start_native_peer
}
