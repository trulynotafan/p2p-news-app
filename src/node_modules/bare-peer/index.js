const b4a = require('b4a')
const Corestore = require('corestore')
const Hyperswarm = require('hyperswarm')
const process = require('bare-process')
const protomux = require('protomux')
const { create_mnemonic_keypair, save, load } = require('../helpers/crypto-helpers/index.js')
const { identity_exchange_protocol } = require('../helpers/protocol-helpers/index.js')
const blog_helper = require('../helpers/blog-helpers/index.js')
const fs = require('bare-fs')
const path = require('bare-path')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

// file-based subscription management 
const SUB_FILE = path.join(process.cwd(), 'subscribed_peers.json')
const file_subscription = {
  get() {
    try { return JSON.parse(fs.readFileSync(SUB_FILE, 'utf8')) } catch { return [] }
  },
  add(key) {
    const arr = this.get()
    if (!arr.includes(key)) arr.push(key)
    fs.writeFileSync(SUB_FILE, JSON.stringify(arr))
  },
  remove(key) {
    const arr = this.get().filter(k => k !== key)
    fs.writeFileSync(SUB_FILE, JSON.stringify(arr))
  }
}
blog_helper.set_subscription_store(file_subscription)

async function start_native_peer(options = {}) {
  const name = options.name || `native-peer-${process.pid}`
  const label = `\x1b[${process.pid % 2 ? 31 : 34}m[peer-${name}]\x1b[0m`

  console.log(label, 'start')

  let seedphrase = await load(name)
  let mnemonic_data
  
  if (seedphrase) {
    console.log(label, 'Loaded existing seedphrase')
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise',
      mnemonic: seedphrase
    })
  } else {
    mnemonic_data = await create_mnemonic_keypair({
      namespace: 'noisekeys',
      name: 'noise'
    })
    await save(mnemonic_data.mnemonic, name)
    console.log(label, 'Generated and saved new mnemonic')
  }
  
  console.log(label, 'Generated mnemonic:', mnemonic_data.mnemonic)
  console.log(label, 'Peer key:', mnemonic_data.keypair.publicKey.toString('hex'))

  const store = new Corestore(`./storage-${name}`)
  await blog_helper.init_blog(store, name)
  const blog_core = store.get({ name: 'blog-feed' })
  await blog_core.ready()
  console.log(label, 'âœ… Blog system ready')

  const swarm = new Hyperswarm({ key_pair: mnemonic_data.keypair })

  swarm.on('connection', on_connection)
  console.log(label, 'Joining swarm')
  swarm.join(topic, { server: true, client: true })
  swarm.flush()
  console.log('Swarm Joined, looking for peers')

  async function on_connection(socket, info) {
    const peer_id = info.publicKey.toString('hex')

    socket.on('close', () => {
      console.log(label, `Peer disconnected [${peer_id.slice(0, 8)}]`)
    })

    socket.on('error', err => {
      if (!err.message?.includes('Duplicate connection')) {
        console.log(label, `connection error [${peer_id.slice(0, 8)}]:`, err.message)
      }
    })

    const mux = new protomux(socket)

    const handlers = {
      on_protocol: async (message, send) => {
        if (message.data && message.data.name) {
          console.log(label, `Discovered peer: ${message.data.name} (${message.data.mode})`)
        }
      },
      on_feedkey: async ({ key_buffer }, send) => {
        try {
          const hex_key = b4a.toString(key_buffer, 'hex')
          console.log(label, `Received feed key from [${peer_id.slice(0, 8)}]: ${hex_key.slice(0, 8)}`)
          // Let blog_helper handle discovery and subscription
          store.emit('core', store.get(key_buffer))
        } catch (err) {
          console.error(label, `Error handling peer core [${peer_id.slice(0, 8)}]:`, err)
        }
      }
    }

    const init_fn = (send) => {
      try {
        console.log(label, `Sending identity to [${peer_id.slice(0, 8)}]`)
        send({
          type: 'protocol',
          data: {
            name: name,
            mode: 'native',
            device_public_key: mnemonic_data.keypair.publicKey.toString('hex')
          }
        })
        send({
          type: 'feedkey',
          data: blog_core.key.toString('hex')
        })
        console.log(label, `Identity exchanged with [${peer_id.slice(0, 8)}]`)
      } catch (err) {
        console.error(label, `Error in identity exchange [${peer_id.slice(0, 8)}]:`, err)
      }
    }

    const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
      peer_mode: 'native',
      label
    })
    
    const identity_channel = setup_protocol(mux)
    identity_channel.open()

    store.replicate(socket)
  }

  return {
    blog_helper,
    store,
    swarm,
    blog_core,
    subscribe: async function (peer_key) {
      return await blog_helper.subscribe(peer_key)
    }
  }
}

module.exports = {
  start: start_native_peer
}