const b4a = require('b4a')
const Hyperswarm = require('hyperswarm')
const DHT = require('@hyperswarm/dht-relay')
const Stream = require('@hyperswarm/dht-relay/ws')
const HyperWebRTC = require('hyper-webrtc')
const Protomux = require('protomux')
const Corestore = require('corestore')
const RAW = require('random-access-web')
const { create_mnemonic_keypair, save, load } = require('helpers/crypto-helpers')
const { identity_exchange_protocol } = require('helpers/protocol-helpers')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')
const PEERS_STORAGE_KEY = 'discovered_peers'

async function start_browser_peer (options = {}) {
  const name = options.name || 'browser-peer'
  const is_dev = location.hostname === 'localhost' || location.hostname.startsWith('192.') || location.hostname.startsWith('10.')
  const relay_url = options.relay || (is_dev ? 'ws://localhost:8080' : 'wss://p2p-relay-production.up.railway.app')

  const store = new Corestore(RAW(`blogs-${name}`))
  
  // load saved peers
  let saved_peers = {}
  try {
    const saved = localStorage.getItem(PEERS_STORAGE_KEY)
    if (saved) saved_peers = JSON.parse(saved)
  } catch (err) {
    console.error('Error loading saved peers:', err)
  }

  await store.ready()
  const core = store.get({ name: 'test-core' })
  const blog_core = store.get({ name: 'blog-feed' })
  await Promise.all([core.ready(), blog_core.ready()])
  if (core.length === 0) await core.append('This is some data')

  return new Promise((resolve, reject) => {
    const socket = new WebSocket(relay_url)
    socket.addEventListener('error', err => {
      // If its an invalid url, reject If it's a valid url thats down, resolve offline
      const errorMessage = err.message || err.toString() || ''
      if (errorMessage.includes('Invalid URL') || errorMessage.includes('URL scheme') || errorMessage.includes('ERR_INVALID_URL')) {
        reject(new Error(`Invalid relay URL: ${relay_url}`))
      } else {
        resolve({ store, core, blog_core, swarm: null, dht: null, cleanup: () => {} })
      }
    })
    socket.addEventListener('close', () => console.log('WebSocket closed'))

    socket.addEventListener('open', async () => {
      // key management
      const seedphrase = await load(name)
      const mnemonic_data = seedphrase
        ? await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise', mnemonic: seedphrase })
        : await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise' })

      if (!seedphrase) await save(mnemonic_data.mnemonic, name)
      console.log('Peer key:', b4a.toString(mnemonic_data.keypair.publicKey, 'hex'))

      const dht = new DHT(new Stream(true, socket))
      const swarm = new Hyperswarm({ dht, key_pair: mnemonic_data.keypair })

      console.log('Joining swarm')
      const discovery = swarm.join(topic, { server: true, client: true })
      await discovery.flushed().catch(err => console.warn('Flush warning:', err.message))
      console.log('Swarm joined')

      // Only accept connections after fully joined
      swarm.on('connection', (relay, details) => {
        if (!relay.userData) relay.userData = null
        const mux = new Protomux(relay)

        // protocol handlers
        const handlers = {
          on_protocol: async (message, send, current_peer_mode) => {
            // Store discovered relay
            if (message.data.relay_url) {
              if (!window.discovered_relays) window.discovered_relays = new Set()
              window.discovered_relays.add(message.data.relay_url)
            }
            
            if (message.data.mode === 'browser' && current_peer_mode === 'browser') {
              const stream = HyperWebRTC.from(relay, { initiator: relay.isInitiator })
              stream.on('open', () => {
                console.log('WebRTC connection established')
                send({ type: 'feedkey', data: b4a.toString(blog_core.key, 'hex') })
                store.replicate(stream, { live: true, encrypt: true, download: true })
              })
              stream.on('close', () => console.log('WebRTC connection closed'))
              stream.on('error', err => {
                if (!err.message?.includes('Abort') && !err.message?.includes('closed')) {
                  console.warn('WebRTC error:', err.message)
                }
              })
            } else if (message.data.mode === 'native') {
              send({ type: 'feedkey', data: b4a.toString(blog_core.key, 'hex') })
              store.replicate(relay, { live: true, encrypt: true, download: true })
            }
          },

          on_feedkey: async ({ key_buffer }) => {
            const hex_key = b4a.toString(key_buffer, 'hex')
            const cloned_core = store.get(key_buffer)
            await cloned_core.ready()

            // update saved peers
            if (!saved_peers[hex_key]) {
              saved_peers[hex_key] = { last_seen: Date.now(), key: hex_key }
              localStorage.setItem(PEERS_STORAGE_KEY, JSON.stringify(saved_peers))
            }

            // only emit core once for discovery
            store.emit('core', cloned_core)

            // append handler
            cloned_core.on('append', async () => {
              try {
                const raw = await cloned_core.get(cloned_core.length - 1)
                const data = JSON.parse(b4a.toString(raw, 'utf-8'))

                saved_peers[hex_key].last_seen = Date.now()
                localStorage.setItem(PEERS_STORAGE_KEY, JSON.stringify(saved_peers))

                if (data.type === 'blog-init' && !saved_peers[hex_key].initialized) {
                  store.emit('blog-discovered', cloned_core)
                  saved_peers[hex_key].initialized = true
                  localStorage.setItem(PEERS_STORAGE_KEY, JSON.stringify(saved_peers))
                } else if (data.type === 'blog-post' || data.type === 'peer-blog-post') {
                  store.emit('feed', cloned_core)
                }
              } catch (err) {
                console.error('Error processing data:', err)
              }
            })

            // initial core check
            if (cloned_core.length > 0 && !saved_peers[hex_key].initialized) {
              try {
                const data = JSON.parse(b4a.toString(await cloned_core.get(0)))
                if (data.type === 'blog-init') {
                  store.emit('blog-discovered', cloned_core)
                  saved_peers[hex_key].initialized = true
                  localStorage.setItem(PEERS_STORAGE_KEY, JSON.stringify(saved_peers))
                }
              } catch (err) {}
            }
          }
        }

        // protocol setup
        const init_fn = (send) => {
          send({
            type: 'protocol',
            data: {
              name,
              mode: 'browser',
              device_public_key: b4a.toString(mnemonic_data.keypair.publicKey, 'hex'),
              relay_url: relay_url
            }
          })
        }

        const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
          peer_mode: 'browser',
          label: '[browser-peer]'
        })

        const identity_channel = setup_protocol(mux)
        identity_channel.open()

        relay.on('close', () => console.log('Peer disconnected'))
        relay.on('error', err => {
          if (!err.message?.includes('Duplicate connection')) {
            console.warn('Relay error:', err.message)
          }
        })
      })

      // join interval
      const join_interval = setInterval(() => {
        swarm.join(topic, { server: true, client: true })
          .flushed()
          .catch(err => console.warn('Join warning:', err.message))
      }, 5000)

      resolve({ store, core, blog_core, swarm, dht, cleanup: () => clearInterval(join_interval) })
    })
  })
}

module.exports = { start: start_browser_peer }
