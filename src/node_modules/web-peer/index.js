const b4a = require('b4a')
const Hyperswarm = require('hyperswarm')
const DHT = require('@hyperswarm/dht-relay')
const Stream = require('@hyperswarm/dht-relay/ws')
const HyperWebRTC = require('hyper-webrtc')
const Protomux = require('protomux')
const Corestore = require('corestore')
const RAW = require('random-access-web')
const { create_mnemonic_keypair, save, load } = require('helpers/crypto-helpers')
const { identity_exchange_protocol } = require('helpers/protocol-helpers')
const pairing_helper = require('../helpers/pairing-helper')
const blog_helper = require('../helpers/blog-helpers')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')
const PEERS_STORAGE_KEY = 'discovered_peers'

async function start_browser_peer (options = {}) {
  const name = options.name || 'browser-peer'
  const invite_code = options.invite_code // For joining existing networks
  const is_dev = location.hostname === 'localhost' || location.hostname.startsWith('192.') || location.hostname.startsWith('10.')
  const relay_url = options.relay || (is_dev ? 'ws://localhost:8080' : 'wss://relay-production-9c0e.up.railway.app')
  const get_blog_key = options.get_blog_key
  const get_blog_autobase = options.get_blog_autobase
  const get_metadata_store = options.get_metadata_store
  const get_drive_store = options.get_drive_store

  const store = new Corestore(RAW(`blogs-${name}`))
  
  // load saved peer
  let saved_peers = {}
  try {
    const saved = localStorage.getItem(PEERS_STORAGE_KEY)
    if (saved) saved_peers = JSON.parse(saved)
  } catch (err) {
    console.error('Error loading saved peers:', err)
  }

  await store.ready()
  const core = store.get({ name: 'test-core' })
  await core.ready()
  if (core.length === 0) await core.append('This is some data')

  return new Promise((resolve, reject) => {
    const socket = new WebSocket(relay_url)
    socket.addEventListener('error', err => {
      // If its an invalid url, reject If it's a valid url thats down, resolve offline
      const errorMessage = err.message || err.toString() || ''
      if (errorMessage.includes('Invalid URL') || errorMessage.includes('URL scheme') || errorMessage.includes('ERR_INVALID_URL')) {
        reject(new Error(`Invalid relay URL: ${relay_url}`))
      } else {
        resolve({ store, core, swarm: null, dht: null, cleanup: () => {} })
      }
    })
    socket.addEventListener('close', () => console.log('WebSocket closed'))

    socket.addEventListener('open', async () => {
      // key management
      const seedphrase = await load(name)
      const mnemonic_data = seedphrase
        ? await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise', mnemonic: seedphrase })
        : await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise' })

      if (!seedphrase) await save(mnemonic_data.mnemonic, name)
      console.log('Peer key:', b4a.toString(mnemonic_data.keypair.publicKey, 'hex'))

      const dht = new DHT(new Stream(true, socket))
      const swarm = new Hyperswarm({ dht, key_pair: mnemonic_data.keypair })

      // Set up connection handler BEFORE joining
      swarm.on('connection', (relay, details) => {
        console.log('New connection established')
        if (!relay.userData) relay.userData = null
        const mux = new Protomux(relay)

        // protocol handlers
        const handlers = {
          on_protocol: async (message, send, current_peer_mode) => {
            // Store discovered relay
            if (message.data.relay_url) {
              if (!window.discovered_relays) window.discovered_relays = new Set()
              window.discovered_relays.add(message.data.relay_url)
            }
            
            if (message.data.mode === 'browser' && current_peer_mode === 'browser') {
              const stream = HyperWebRTC.from(relay, { initiator: relay.isInitiator })
              stream.on('open', () => {
                console.log('WebRTC connection established')
                const blog_key = get_blog_key ? get_blog_key() : null
                if (blog_key) send({ type: 'feedkey', data: blog_key })
                
                // Setup corestore replication for WebRTC connections
                const metadata_store = get_metadata_store ? get_metadata_store() : null
                const drive_store = get_drive_store ? get_drive_store() : null
                
                if (metadata_store && drive_store) {
                  metadata_store.replicate(stream)
                  drive_store.replicate(stream)
                }
              })
              stream.on('close', () => console.log('WebRTC connection closed'))
              stream.on('error', err => {
                if (!err.message?.includes('Abort') && !err.message?.includes('closed')) {
                  console.warn('WebRTC error:', err.message)
                }
              })
            } else if (message.data.mode === 'native') {
              const blog_key = get_blog_key ? get_blog_key() : null
              if (blog_key) send({ type: 'feedkey', data: blog_key })
              
              // Setup corestore replication for peer connections
              const metadata_store = get_metadata_store ? get_metadata_store() : null
              const drive_store = get_drive_store ? get_drive_store() : null
              
              if (metadata_store && drive_store) {
                metadata_store.replicate(relay)
                drive_store.replicate(relay)
              }
            }
          },

          on_feedkey: async ({ key_buffer }) => {
            const hex_key = b4a.toString(key_buffer, 'hex')
            store.emit('peer-autobase-key', { key: hex_key, key_buffer })
          }
        }

        // protocol setup
        const init_fn = (send) => {
          send({
            type: 'protocol',
            data: {
              name,
              mode: 'browser',
              device_public_key: b4a.toString(mnemonic_data.keypair.publicKey, 'hex'),
              relay_url: relay_url
            }
          })
        }

        const setup_protocol = identity_exchange_protocol(handlers, init_fn, {
          peer_mode: 'browser',
          label: '[browser-peer]'
        })

        const identity_channel = setup_protocol(mux)
        identity_channel.open()

        store.on('peer-add', (peer) => {
          store.emit('peer-autobase-key', { 
            key: b4a.toString(get_blog_autobase().key, 'hex'),
            key_buffer: get_blog_autobase().key
          })
        })

        relay.on('close', () => console.log('Peer disconnected'))
        relay.on('error', err => {
          if (!err.message?.includes('Duplicate connection')) {
            console.warn('Relay error:', err.message)
          }
        })
      })

      // Now join the swarm AFTER setting up the connection handler
      console.log('Joining swarm')
      const discovery = swarm.join(topic, { server: true, client: true })
      
      const join_interval = setInterval(() => {
        swarm.join(topic, { server: true, client: true })
          .flushed()
          .catch(err => console.warn('Join warning:', err.message))
      }, 5000)

      // Attach swarm to store for easy access in blog-helpers
      store.swarm = swarm
      
      // Handle pairing if invite_code is provided
      if (invite_code) {
        handle_join_with_invite(invite_code, swarm, store, name)
      }
      
      resolve({ store, core, swarm, dht, cleanup: () => clearInterval(join_interval) })
      
      // Flush in background, don't block UI
      discovery.flushed().catch(err => console.warn('Flush warning:', err.message)).then(() => {
        console.log('Swarm joined')
      })
    })
  })
}

// Handle joining with invite code
async function handle_join_with_invite(invite_code, swarm, store, username) {
  try {
    const result = await pairing_helper.join_with_invite(invite_code, swarm, store)
    
    // Setup corestore replication
    swarm.on('connection', (conn) => {
      result.metadata_store.replicate(conn)
      result.drive_store.replicate(conn)
    })
    
    for (const conn of swarm.connections) {
      result.metadata_store.replicate(conn)
      result.drive_store.replicate(conn)
    }
    
    // Initialize blog with shared access
  await blog_helper.init_blog(
  store, 
  username, 
  result.drive_key, 
  result.autobase_key,
  result.metadata_store,
  result.drive_store
)
    
  } catch (err) {
    console.error('Pairing error:', err)
  }
}

module.exports = { start: start_browser_peer }