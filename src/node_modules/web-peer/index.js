const b4a = require('b4a')
const Hyperswarm = require('hyperswarm')
const DHT = require('@hyperswarm/dht-relay')
const Stream = require('@hyperswarm/dht-relay/ws')
const HyperWebRTC = require('hyper-webrtc')
const Protomux = require('protomux')
const Corestore = require('corestore')
const RAW = require('random-access-web')
const { create_mnemonic_keypair, save, load } = require('helpers/crypto-helpers')
const { identity_exchange_protocol } = require('helpers/protocol-helpers')
const pairing_helper = require('../helpers/pairing-helper')
const blog_helper = require('../helpers/blog-helpers')

const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')
const PEERS_STORAGE_KEY = 'discovered_peers'

async function start_browser_peer (options = {}) {
  const name = options.name || 'browser-peer'
  const invite_code = options.invite_code // For joining existing networks
  const is_dev = location.hostname === 'localhost' || location.hostname.startsWith('192.') || location.hostname.startsWith('10.')
  const relay_url = options.relay || (is_dev ? 'ws://localhost:8080' : 'wss://relay-production-9c0e.up.railway.app')
  const get_blog_key = options.get_blog_key
  const get_blog_autobase = options.get_blog_autobase
  const get_metadata_store = options.get_metadata_store
  const get_drive_store = options.get_drive_store
  const get_profile_store = options.get_profile_store

  const store = new Corestore(RAW(`blogs-${name}`))

  // load saved peer
  let saved_peers = {}
  try {
    const saved = localStorage.getItem(PEERS_STORAGE_KEY)
    if (saved) saved_peers = JSON.parse(saved)
  } catch (err) {
    console.error('Error loading saved peers:', err)
  }

  await store.ready()
  const core = store.get({ name: 'test-core' })
  await core.ready()
  if (core.length === 0) await core.append('This is some data')

  return new Promise((resolve, reject) => {
    const socket = new WebSocket(relay_url)

    function handle_socket_error (err) {
      // If invalid URL, reject. If valid URL but down, go offline mode
      const errorMessage = err.message || err.toString() || ''
      if (errorMessage.includes('Invalid URL') || errorMessage.includes('URL scheme') || errorMessage.includes('ERR_INVALID_URL')) {
        reject(new Error(`Invalid relay URL: ${relay_url}`))
      } else {
        function handle_cleanup () {
          // cleanup function
        }
        resolve({ store, core, swarm: null, dht: null, cleanup: handle_cleanup })
      }
    }

    function handle_socket_close () {
      console.log('WebSocket closed')
    }

    socket.addEventListener('error', handle_socket_error)
    socket.addEventListener('close', handle_socket_close)

    async function handle_socket_open () {
      try {
        // Verify socket is ready
        if (socket.readyState !== WebSocket.OPEN) {
          console.error('Socket not ready:', socket.readyState)
          return
        }

        // key management
        const seedphrase = await load(name)
        const mnemonic_data = seedphrase
          ? await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise', mnemonic: seedphrase })
          : await create_mnemonic_keypair({ namespace: 'noisekeys', name: 'noise' })

        if (!seedphrase) await save(mnemonic_data.mnemonic, name)
        console.log('Peer key:', b4a.toString(mnemonic_data.keypair.publicKey, 'hex'))

        // Create DHT stream with error handling
        // Create DHT stream
        const stream = new Stream(true, socket)
        console.log('Initializing DHT...')
        const dht = new DHT(stream)
        const swarm = new Hyperswarm({ dht, key_pair: mnemonic_data.keypair })

        // Set up connection handler BEFORE joining
        function handle_swarm_connection (relay, details) {
          console.log('New connection established')
          if (!relay.userData) relay.userData = null
          const mux = new Protomux(relay)

          // protocol handlers
          async function handle_protocol_message (message, send, current_peer_mode) {
          // Store discovered relay for potential future connections
            if (message.data.relay_url) {
              if (!window.discovered_relays) window.discovered_relays = new Set()
              window.discovered_relays.add(message.data.relay_url)
            }

            if (message.data.mode === 'browser' && current_peer_mode === 'browser') {
              const stream = HyperWebRTC.from(relay, { initiator: relay.isInitiator }) // Upgrade to WebRTC

              function handle_webrtc_open () {
                console.log('WebRTC connection established')
                const blog_key = get_blog_key ? get_blog_key() : null
                if (blog_key) send({ type: 'feedkey', data: blog_key }) // Share our blog key

                // Setup corestore replication for WebRTC connections
                const metadata_store = get_metadata_store ? get_metadata_store() : null
                const drive_store = get_drive_store ? get_drive_store() : null
                const profile_store = get_profile_store ? get_profile_store() : null

                if (metadata_store && drive_store && profile_store) {
                  metadata_store.replicate(stream)
                  drive_store.replicate(stream)
                  profile_store.replicate(stream)
                }
              }

              function handle_webrtc_close () {
                console.log('WebRTC connection closed')
              }

              // mostly returns undefined so for debugging logging whole error.

              function handle_webrtc_error (err) {
                if (!err || (!err.message?.includes('Abort') && !err.message?.includes('closed'))) {
                  console.warn('WebRTC error details:', {
                    message: err?.message,
                    code: err?.code,
                    stack: err?.stack,
                    fullError: err
                  })
                }
              }

              stream.on('open', handle_webrtc_open)
              stream.on('close', handle_webrtc_close)
              stream.on('error', handle_webrtc_error)
            } else if (message.data.mode === 'native') {
              const blog_key = get_blog_key ? get_blog_key() : null
              if (blog_key) send({ type: 'feedkey', data: blog_key }) // Share our blog key

              // Setup corestore replication for native peer connections
              const metadata_store = get_metadata_store ? get_metadata_store() : null
              const drive_store = get_drive_store ? get_drive_store() : null
              const profile_store = get_profile_store ? get_profile_store() : null

              if (metadata_store && drive_store && profile_store) {
                metadata_store.replicate(relay) // Use relay stream directly
                drive_store.replicate(relay)
                profile_store.replicate(relay)
              }
            }
          }

          async function handle_feedkey_message ({ key_buffer }) {
            const hex_key = b4a.toString(key_buffer, 'hex')
            store.emit('peer-autobase-key', { key: hex_key, key_buffer })
          }

          const handlers = {
            on_protocol: handle_protocol_message,

            on_feedkey: handle_feedkey_message
          }

          // protocol setup
          function handle_protocol_init (send) {
            send({
              type: 'protocol',
              data: {
                name,
                mode: 'browser',
                device_public_key: b4a.toString(mnemonic_data.keypair.publicKey, 'hex'),
                relay_url: relay_url
              }
            })
          }

          const setup_protocol = identity_exchange_protocol(handlers, handle_protocol_init, {
            peer_mode: 'browser',
            label: '[browser-peer]'
          })

          const identity_channel = setup_protocol(mux)
          identity_channel.open()

          function handle_peer_add (peer) {
            store.emit('peer-autobase-key', {
              key: b4a.toString(get_blog_autobase().key, 'hex'),
              key_buffer: get_blog_autobase().key
            })
          }

          store.on('peer-add', handle_peer_add)

          function handle_relay_close () {
            console.log('Peer disconnected')
          }

          function handle_relay_error (err) {
            if (!err.message?.includes('Duplicate connection')) {
              console.warn('Relay error:', err.message)
            }
          }

          relay.on('close', handle_relay_close)
          relay.on('error', handle_relay_error)
        }

        swarm.on('connection', handle_swarm_connection)

        // Now join the swarm AFTER setting up the connection handler
        console.log('Joining swarm')
        const discovery = swarm.join(topic, { server: true, client: true })

        function handle_periodic_join () {
          function handle_join_warning (err) {
            console.warn('Join warning:', err.message)
          }

          swarm.join(topic, { server: true, client: true })
            .flushed()
            .catch(handle_join_warning)
        }

        const join_interval = setInterval(handle_periodic_join, 5000)

        // Attach swarm to store for easy access in blog-helpers
        store.swarm = swarm

        // Handle pairing if invite_code is provided (joining existing blog)
        if (invite_code) {
          handle_join_with_invite({ invite_code, swarm, store, username: name })
        }

        function handle_cleanup () {
          clearInterval(join_interval)
        }

        resolve({ store, core, swarm, dht, cleanup: handle_cleanup })

        // Flush in background, don't block UI
        function handle_flush_warning (err) {
          console.warn('Flush warning:', err.message)
        }

        function handle_flush_success () {
          console.log('Swarm joined')
        }

        discovery.flushed().catch(handle_flush_warning).then(handle_flush_success)
      } catch (error) {
        console.error('Error in socket open handler:', error)
        reject(error)
      }
    }

    socket.addEventListener('open', handle_socket_open)
  })
}

// Handle joining with invite code
async function handle_join_with_invite (options) {
  const { invite_code, swarm, store, username } = options
  try {
    const result = await pairing_helper.join_with_invite({ invite_code, swarm, store })

    // Initialize blog with shared access (without profile_drive_key yet)
    await blog_helper.init_blog({
      store_instance: store,
      username,
      drive_key: result.drive_key,
      autobase_key: result.autobase_key
    })

    // Helper function to setup secondary drives
    async function setup_secondary_drive (type, getter, setter, namespace) {
      let drive_key = await getter()
      
      if (!drive_key) {
        drive_key = await new Promise((resolve) => {
          async function handle_update () {
            const key = await getter()
            if (key) resolve(key)
          }
          blog_helper.on_update(handle_update)
        })
      }

      console.log(`[pairing] ${type}_drive_key from blog-init:`, drive_key ? drive_key.slice(0, 16) : 'null')
      
      if (drive_key) {
        const b4a = require('b4a')
        const drive_store = store.namespace(namespace)
        const { create_autodrive } = require('../autodrive')
        const drive = create_autodrive({ store: drive_store, bootstrap: b4a.from(drive_key, 'hex') })
        await drive.ready()
        setter(drive, drive_store)
        console.log(`[pairing] ${type} drive created and set`)
      }
    }

    // Setup profile and events drives
    await setup_secondary_drive('profile', blog_helper.get_blog_profile_drive_key, blog_helper.set_profile_drive, 'blog-profile')
    await setup_secondary_drive('events', blog_helper.get_blog_events_drive_key, blog_helper.set_events_drive, 'blog-events')

    // Setup corestore replication using blog helper stores
    function handle_pairing_connection (conn) {
      blog_helper.get_metadata_store().replicate(conn)
      blog_helper.get_drive_store().replicate(conn)
      const profile_store = blog_helper.get_profile_store()
      if (profile_store) profile_store.replicate(conn)
      const events_store = blog_helper.get_events_store()
      if (events_store) events_store.replicate(conn)
    }

    swarm.on('connection', handle_pairing_connection)

    for (const conn of swarm.connections) {
      blog_helper.get_metadata_store().replicate(conn)
      blog_helper.get_drive_store().replicate(conn)
      const profile_store = blog_helper.get_profile_store()
      if (profile_store) profile_store.replicate(conn)
      const events_store = blog_helper.get_events_store()
      if (events_store) events_store.replicate(conn)
    }
  } catch (err) {
    console.error('Pairing error:', err)
  }
}

module.exports = { start: start_browser_peer }
