
// //JUST FOR TESTING NEW STUFF BEFORE IMPLEMENTATION

// const b4a = require('b4a')
// const Hyperswarm = require('hyperswarm')
// const DHT = require('@hyperswarm/dht-relay')
// const Stream = require('@hyperswarm/dht-relay/ws')
// const HyperWebRTC = require('hyper-webrtc')
// const Protomux = require('protomux')
// const c = require('compact-encoding')
// const Corestore = require('corestore')
// const RAM = require('random-access-memory')

// const topic = b4a.from('ffb09601562034ee8394ab609322173b641ded168059d256f6a3d959b2dc6021', 'hex')

// const store = new Corestore(RAM.reusable())
// const core = store.get({ name: 'test-core' })

// start()

// async function start() {
//   const socket = new WebSocket('ws://localhost:8080')
//   socket.addEventListener('open', () => {
//     console.log(' Connected to DHT relay')
//     const dht = new DHT(new Stream(true, socket))
//     const swarm = new Hyperswarm({ dht })

//     const join = () => swarm.join(topic, { server: true, client: true }).flushed()
//     join().then(() => console.log('ğŸŒ Joined swarm'))
//     setInterval(join, 5000)

//     swarm.on('connection', (relay, details) => {
//       console.log('ğŸ‘‹ New peer connected')

//       if (!relay.userData) relay.userData = null

//       const mux = new Protomux(relay)
//       let hasReceivedFeedkey = false

//       const identity_channel = mux.createChannel({
//         protocol: 'identity-exchange',
//         onopen: () => {
//           const protocol_msg = identity_channel.addMessage({
//             encoding: c.json,
//             onmessage: (message) => {
//               try {
//                 if (message.type === 'protocol') {
//                   console.log(`ğŸ“± Peer type: ${message.data}`)

//                   if (message.data === 'browser') {
//                     const stream = HyperWebRTC.from(relay, { initiator: relay.isInitiator })
//                     console.log('ğŸ”„ Upgrading to WebRTC...')

//                     stream.on('open', () => {
//                       console.log('âœ… WebRTC connection established')
//                       protocol_msg.send({
//                         type: 'feedkey',
//                         feedkey: core.key.toString('hex')
//                       })
//                       store.replicate(stream)
//                     })

//                     stream.on('close', () => console.log('âŒ WebRTC connection closed'))
//                     stream.on('error', (err) => console.error('âš ï¸ WebRTC error:', err))
//                   }
//                 } else if (message.type === 'feedkey' && !hasReceivedFeedkey) {
//                   hasReceivedFeedkey = true

//                   let keyBuffer
//                   if (typeof message.feedkey === 'string' && message.feedkey.includes(',')) {
//                     const numbers = message.feedkey.split(',').map(n => parseInt(n.trim(), 10))
//                     keyBuffer = b4a.allocUnsafe(32)
//                     for (let i = 0; i < 32; i++) keyBuffer[i] = numbers[i]
//                   } else if (typeof message.feedkey === 'string') {
//                     keyBuffer = b4a.from(message.feedkey, 'hex')
//                   } else if (Array.isArray(message.feedkey)) {
//                     keyBuffer = b4a.from(message.feedkey)
//                   }

//                   if (keyBuffer.length !== 32) {
//                     console.error('âŒ Invalid key length:', keyBuffer.length)
//                     return
//                   }

//                   const hexKey = Array.from(keyBuffer).map(b => b.toString(16).padStart(2, '0')).join('')
//                   console.log('ğŸ”‘ Received peer key:', hexKey.substring(0, 16) + '...')

//                   const cloned_core = store.get(keyBuffer)
//                   cloned_core.on('append', onappend)
//                   cloned_core.ready().then(async () => {
//                     console.log('ğŸ“¦ Peer core ready, syncing data...')

//                     const unavailable = []
//                     if (cloned_core.length) {
//                       for (var i = 0, L = cloned_core.length; i < L; i++) {
//                         const raw = await cloned_core.get(i, { wait: false })
//                         if (raw) console.log('ğŸ“„ Local:', raw.toString('utf-8'))
//                         else unavailable.push(i)
//                       }
//                     }

//                     for (var i = 0, L = unavailable.sort().length; i < L; i++) {
//                       const raw = await cloned_core.get(unavailable[i])
//                       console.log('â¬‡ï¸ Downloaded:', raw.toString('utf-8'))
//                     }
//                   }).catch(err => console.error('âŒ Core setup error:', err))
//                 }
//               } catch (err) {
//                 console.error('âŒ Message handling error:', err)
//               }
//             }
//           })

//           protocol_msg.send({
//             type: 'protocol',
//             name: 'browser',
//             data: 'browser'
//           })
//         }
//       })

//       identity_channel.open()
//       relay.on('close', () => console.log('ğŸ‘‹ Peer disconnected'))
//       relay.on('error', (err) => console.error('âš ï¸ Relay error:', err))
//     })
//   })

//   socket.addEventListener('error', console.error)
//   socket.addEventListener('close', () => console.log('âŒ WebSocket closed'))
// }

// async function onappend() {
//   const L = core.length
//   console.log("ğŸ“¥ New data available")
//   const raw = await core.get(L - 1)
//   console.log('ğŸ“„ New message:', raw.toString('utf-8'))
// }
